\documentclass[FM,bw,DP]{tulthesis}

\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}
\usepackage{setspace}
\usepackage[export]{adjustbox}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[hyphens]{url}
\usepackage[hidelinks,unicode,hyperfootnotes=false]{hyperref}
\usepackage{float}
\usepackage{subfig}
\usepackage{longtable}
\usepackage[nonumberlist,acronym]{glossaries}
\usepackage{enumitem}
\usepackage[toc]{appendix}
\usepackage{dirtree}

% no vertical spcaing between items in list
\setlist{nosep}

% set figure counter to global
\usepackage{chngcntr}
\counterwithout*{figure}{chapter}

% fix footnotes in table environments
\usepackage{footnote}
\makesavenoteenv{tabular}
\makesavenoteenv{table}

% create fixed sized table columns
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

% customize description environment
\usepackage{enumitem}

% table of contents looks
%\usepackage[tocflat]{tocstyle}
%\usetocstyle{standard}

\renewcommand{\thetable}{\arabic{table}}
\renewcommand{\thefigure}{\arabic{figure}}

\newcommand{\includeumlgraph}[2]{%
\begin{figure}[h]
	\centering
    \includegraphics[max width=\textwidth]{../img/graphs/#1.pdf}
    \caption{#2}
	\label{uml:#1}
\end{figure}
}

\newcommand{\includeimg}[2]{%
\begin{figure}[h]
	\centering
    \includegraphics[max width=\textwidth]{../img/#1.pdf}
    \caption{#2}
	\label{img:#1}
\end{figure}
}

\newcommand{\noskipamount}{
{1pt plus 1pt minus 1pt}
}

\lstdefinestyle{code}{ %
  basicstyle=\small\ttfamily,        % the size of the fonts that are used for the code
  aboveskip={1pt plus 1pt minus 1pt},
  belowskip={1pt plus 1pt minus 1pt},
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=L,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=8pt,                   % how far the line-numbers are from the code
  numberstyle=\footnotesize\color{gray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  xleftmargin=\parindent,
  numberbychapter=false
}

\lstdefinestyle{short}{
  frame=none,
  aboveskip={0pt plus 0pt minus 0pt},
  belowskip={0pt plus 0pt minus 0pt},
  numbers=none,
  showlines=true,  % empty lines at the end for easier formatting
  basicstyle=\ttfamily,
}

\lstset{style=code}

\onehalfspacing

\TULtitle{Editor konfiguračních souborů Flow123d}{Flow123d configuration file editor}
\TULprogramme{N2612}{Elektrotechnika a~informatika}%
{Electrotechnology and informatics}
\TULbranch{1802T007}{Informační technologie}%
{Information technology}
\TULauthor{Bc. Tomáš Křížek}
\TULsupervisor{doc. Ing. Jiřina Královcová, Ph.D.}
\TULyear{2016}

\makenoidxglossaries

% glossaries
\setacronymstyle{long-short}
\newacronym{API}{API}{Application Programming Interface}
\newacronym{CON}{CON}{C++ Object Notation}
\newacronym{JSON}{JSON}{JavaScript Object Notation}
\newacronym{XML}{XML}{Extensible Markup Language}
\newacronym{SGML}{SGML}{Standard Generalized Markup Language}
\newacronym{HTML}{HTML}{HyperText Markup Language}
\newacronym{W3C}{W3C}{World Wide Web Consorcium}
\newacronym{YAML}{YAML}{YAML Ain't Markup Language}
\newacronym{DTD}{DTD}{Document Type Definition}
\newacronym{IST}{IST}{Input Structure Tree}
\newacronym{UML}{UML}{Unified Modeling Language}
\newacronym{FSF}{FSF}{Free Software Foundation}
\newacronym{GNU}{GNU}{GNU's Not Unix}
\newacronym{GPL}{GPL}{General Public License}
\newacronym{ECMA}{ECMA}{European Computer Manufacturers Association}
\newacronym{ISO}{ISO}{International Organization for Standardization}
\newacronym{OMG}{OMG}{Object Management Group}
\newacronym{PSF}{PSF}{Python Software Foundation}
\newacronym{RCL}{RCL}{Riverbank Computing Limited}
\newacronym{CSS}{CSS}{Cascading Style Sheets}
\newacronym{JS}{JS}{JavaScript}
\newacronym{TDD}{TDD}{Test Driven Development}



\begin{document}
\ThesisStart{male}


\clearpage
\thispagestyle{empty}
\begin{acknowledgement}
Rád bych poděkoval rodičům za podporu při studiu. Zároveň bych chtěl poděkovat i~mé vedoucí diplomové práce, paní doc. Jiřině Královcové, a~mému konzultantovi, panu Ing. Pavlu Richterovi, za vedení práce a~konzultace.
\end{acknowledgement}


\begin{abstractCZ}
\thispagestyle{empty}
Tato diplomová práce popisuje problematiku související s~tvorbou editoru konfiguračních souborů pro simulátor Flow123d. Představuje formát \acrshort{YAML} jako náhradu staršího souborového formátu \acrshort{CON} a~popisuje použití jeho syntaxe. Dále práce detailně popisuje autokonverze a~proces validace datové struktury. Naposled jsou popsány i samotné komponenty vzniklého editoru ModelEditor.

\vspace{5pt}
\subsection*{Klíčová slova}
\vspace{-10pt}

editor, YAML, autokonverze, validace, Flow123d
\end{abstractCZ}

\vspace{2cm}
\begin{abstractEN}
This paper describes the issues surrounding the development of the Flow123d configuration file editor. It introduces the \acrshort{YAML} format as a~replacement of the previously used \acrshort{CON} format and explains the new syntax. This paper also describes the process of autoconversion and validation of the Flow123d data structure in detail. Finally, components of the developed editor, ModelEditor, are described.

\vspace{5pt}
\subsection*{Keywords}
\vspace{-10pt}

editor, YAML, autoconversion, validation, Flow123d
\end{abstractEN}


\renewcommand\contentsname{Obsah\vspace{-15pt}}
\tableofcontents
\clearpage

\renewcommand\listfigurename{Seznam obrázků\vspace{-5pt}}
\listoffigures
\clearpage


\addtocontents{toc}{\protect\setcounter{tocdepth}{-1}}

\printnoidxglossary[type=\acronymtype,title=Seznam zkratek]

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}

\chapter*{Úvod}
\addcontentsline{toc}{chapter}{Úvod}

\vspace{-2pt}

Existuje celá řada aplikací, která potřebuje pro zajištění požadované funkce správné nastavení, podle kterého pak daná aplikace přizpůsobí svoji činnost. Může se jednat o~počáteční konfiguraci, jako je tomu například u~serverových aplikací nebo e-mailových klientů. Tato konfigurace se zpravidla dále nemění, pokud nedojde k~nějakým podstatným změnám.

Oproti tomu existují aplikace, od kterých se očekává, že budou spouštěny s~širokou škálou různých nastavení. U~těchto aplikací se typicky konfigurace předává při spuštění jako jeden ze vstupních parametrů. Činnost těchto aplikací se pak zásadně liší dle zvolené konfigurace.

Takovou aplikací je například simulátor Flow123d, který se používá pro modelování procesů v~horninovém prostředí. Vstupem do této aplikace je výpočetní síť společně se zadáním úlohy. Konkrétní úloha je definovaná pomocí konfiguračního souboru, který vytváří uživatel. Po zadání vstupních dat provede simulátor výpočty na dané síti a~výsledky uloží do datového souboru, který je výstupem z~aplikace.

Simulátor Flow123d podporuje různé typy úloh. Konfigurace jednotlivých úloh vyžaduje odlišné nastavení a~může tedy dojít k~tomu, že uživatelem zadaná konfigurace je nevalidní -- například kvůli tomu, že definice dané úlohy neobsahuje některé povinné parametry a~je tedy neúplná. V~souboru může vzniknout i~syntaktická chyba, která způsobí, že zadaná data nelze správně interpretovat.

Specifikace formátu konfiguračních souborů pro Flow123d, která popisuje strukturu vstupních dat, je poměrně rozsáhlá. Tištěná referenční příručka, která obsahuje tuto specifikaci formátu, má několik desítek stran. To klade na uživatele velké nároky. Pokud chce například ověřit, že byly zadány všechny povinné parametry, buď musí mít se softwarem rozsáhlé zkušenosti, nebo musí trávit velké množství času studiem této dokumentace a~zkoumáním souvislostí mezi parametry.

Celá situace je dále komplikována tím, že formát konfiguračních souborů se mění s~tím, jak se vyvíjí nové a~upřesňují stávající funkcionality simulátoru Flow123d. Může dojít k~tomu, že některé změny ve formátu konfiguračních souborů nemusí být zpětně kompatibilní. Uživatel tedy potřebuje znovu prostudovat rozsáhlou referenční dokumentaci, aby zjistil, jakým způsobem zadat dříve realizovanou úlohu pro novou verzi Flow123d.

Pokud se stane, že uživatel spustí Flow123d s~nevalidní konfigurací, potom během inicializace dojde k~chybě, o~které se uživatel dozví pomocí textového rozhraní, ve kterém se Flow123d spouští. Jelikož se může jednat o~výpočetně náročné úlohy, které se často pouští na vzdáleném výpočetním clusteru, je tento proces poměrně časově náročný a~uživatelsky nepříjemný.

Při vzdáleném spouštění Flow123d se úloha zařadí do fronty na výpočetním clusteru, kde dále čeká na přidělení zdrojů. Ty se přidělují na základě aktuálního vytížení. Buď jsou k~dispozici okamžitě, nebo je nutné čekat na dokončení některých předchozích úloh. Může tedy nastat situace, kdy uživatel zařadí úlohu do fronty a~poté čeká na výsledky několik hodin nebo dokonce dní, a~teprve potom zjistí, že v~konfiguračním souboru, který vytvořil, byla chyba. Kvůli tomu nemohlo dojít k~inicializaci úlohy a~tím pádem ani neproběhla simulace.

Tyto důvody byly hlavní motivací ke vzniku speciálního editoru pro konfigurační soubory Flow123d, který práci s~nimi značně zjednoduší a~usnadní. Tvorba takového editoru je předmětem této diplomové práce. Editor zrychlí proces odstranění chyb tím, že je odhalí už v~průběhu vytváření nebo upravování konfiguračních souborů. Uživatel tedy bude moci chyby odstranit ještě před tím, než předloží konfigurační soubor simulátoru Flow123d. Tím dojde ke značné časové úspoře obzvlášť v~případech, kdy se výpočetní úloha spouští vzdáleně.

Součástí editoru má být grafické uživatelské rozhraní. Jedním z~jeho hlavních přínosů bude zjednodušení přístupu k~dokumentaci. Uživatel bude mít k~dispozici tu část dokumentace, která bezprostředně souvisí s~právě upravovanou částí konfiguračního souboru. Tato forma nápovědy by měla uživateli poskytnout alternativu k~prohledávání rozsáhlé referenční dokumentace.

Dále bude editor umožňovat zobrazit datovou strukturu, která tvoří konfigurační soubor. Kromě toho bude editor poskytovat základní funkce pro práci s~textovými soubory, jako je podpora operací se schránkou, možnost vrátit či opakovat změny, vyhledávání či nahrazení textu a~další. Editor má podporovat platformy Windows a~Linux.

Vlastní text diplomové práce kromě úvodu a závěru je členěn do čtyř hlavních kapitol. První kapitola slouží jako úvod do problematiky. Ve druhé kapitole je podrobně analyzován problém. Třetí kapitola navazuje na předchozí kapitolu a představuje konkrétní návrh řešení rozebraných problémů. V poslední kapitole jsou zmíněny implementační detaily.


\chapter{Problematika}

\section{Simulátor Flow123d}

Flow123d je simulátor, který slouží k~výpočtu proudění v~porézním médiu, transportu látek nebo transportu tepla. Jedná se o~aplikaci, která je orientována na práci s~daty, a~vzhledem k~tomu neobsahuje žádné grafické uživatelské rozhraní. Uživatel tedy s~aplikací pracuje v~textovém režimu prostřednictvím terminálu, kde může aplikaci předat vstupní soubory a~případně další parametry.

\includeimg{flow123d}{Simulátor Flow123d a~pomocný software}

Na obrázku~\ref{img:flow123d} jsou znázorněny vstupy a~výstupy simulátoru Flow123d spolu s~pomocnými aplikacemi, které uživatelé často používají. Vstupem do simulátoru Flow123d jsou dva soubory. První z~těchto souborů popisuje výpočetní síť pomocí seznamu uzlů a~elementů. Jedná se o~textový soubor ve formátu \texttt{.msh}. Tuto síť generují softwary GMSH\footnote{\url{http://www.gmsh.info/}} nebo SALOME\footnote{\url{http://www.salome-platform.org/}}. Druhým vstupním souborem je konfigurační soubor, který popisuje řešenou úlohu. Tento soubor si prozatím uživatelé tvořili sami pomocí obyčejných textových editorů.

Pro tento konfigurační soubor vzniká v~rámci diplomové práce specializovaný editor s~označením \textit{ModelEditor}, který má oproti obyčejnému textovému editoru poskytnout např. validaci zadaných dat, zobrazení kontextové nápovědy nebo automatické doplňování textu. Vytváření a~editace konfiguračních souborů se tak uživateli značně zjednoduší. \textit{ModelEditor} je součástí softwarového balíku \textit{GeoMop}, který obsahuje i~další aplikace, které ovšem nejsou předmětem této práce.

\textit{GeoMop} má sloužit jako nástroj, který usnadní práci se simulátorem Flow123d. Aplikace \textit{JobsScheduler}, která je také součástí softwarového balíku \textit{GeoMop}, bude zajišťovat vzdálené spouštění Flow123d na výpočetních clusterech. Softwarový balík \textit{GeoMop} bude dále obsahovat aplikaci \textit{Analysis}, která umožní parametrizaci úloh. \textit{GeoMop} bude obsahovat i další aplikace, které jsou aktuálně ve vývoji. Je pravděpo\-dobné, že se funkcionalita těchto aplikací bude dále rozšiřovat.

Výstupem ze simulátoru Flow123d je datový soubor, který obsahuje výsledky simulace. U~tohoto souboru si uživatel může vybrat požadovaný formát, podle toho, kterou aplikaci chce použít pro zpracování výsledků. Typicky uživatelé používají buď opět GMSH nebo ParaView\footnote{\url{http://www.paraview.org/}}. Existuje také celá řada jednoúčelových nástrojů, které si uživatelé často tvoří sami, nebo vznikají v~rámci různých projektů.

\section{Konfigurační soubory}

V~současné době (verze Flow123d 1.8.2), se pro zadání úlohy používá jeden konfigurační soubor, který obsahuje všechny potřebné údaje pro definici a~inicializaci úlohy. Z~pohledu Flow123d je úloha definovaná pomocí konkrétních objektů, které mají nastavené různé atributy na požadované hodnoty. 

Vzhledem k~tomu, že úlohy zadávají lidé, je potřeba určit nějaké společné rozhraní, pomocí kterého budou moci definovat tyto objekty a~jejich obsah. Tato definice zároveň musí být strojově čitelná, aby ji simulátor Flow123d mohl zpracovat a~nakonfigurovat se podle ní do správného počátečního stavu pro zahájení výpočtu.

Jelikož se pro předávání dat používají soubory, existují v~principu dvě možnosti, jak předat tato data. Formát souboru může být buď binární, nebo textový. Vzhledem k~tomu, že soubory mají vytvářet lidé, tak by bylo krajně nepraktické, kdyby se použil binární formát souboru.

Textová reprezentace konfiguračních souborů s~sebou kromě čitelnosti přináší i~další výhody. Oproti binárnímu formátu není závislá na architektuře, jelikož všechna data jsou kódována ve formě textu. Textový soubor navíc umožňuje kromě přenosu samotných dat i tato data nějakým způsobem popsat. Díky tomu se změny v interní struktuře Flow123d nemusí nutně projevit ve formátu konfiguračních souborů.

\subsection{Datová struktura}
\label{sec:datova-struktura}
Použití textového formátu konfiguračních souborů s~sebou však přináší otázku, jakým způsobem tato data v~textu reprezentovat. Je důležité, aby pomocí vybraného formátu bylo možné inicializovat libovolnou datovou strukturu. Tato datová struktura se skládá z~objektů, které mají různé atributy. Každý atribut má název (dále označován jako klíč), datový typ a~hodnotu. Ve většině případů platí, že klíč jednoznačně implikuje datový typ. Potom je tedy dostačující ukládat dvojici klíč a~hodnota.

Existují i~situace, kdy z~názvu atributu nelze jednoznačně určit jeho datový typ. To je způsobené použitím polymorfismu. Z~klíče lze tedy odvodit pouze jakého datového typu musí být předek. Pokud má tento předek více potomků, pak je nutné vybraný datový typ explicitně uvést. Tyto situace jsou v~této kapitole zanedbány a~jsou popsány samostatně v~kapitole~\ref{sec:navrh-yaml-abstrakni-zaznamy}.

V~konfiguračních souborech je tedy potřeba ukládat dvojice klíč a~hodnota. Hodnota může být buď primitivního nebo složeného datového typu. Reprezentace primitivních datových typů je většinou triviální a~spočívá pouze v~převodu hodnoty na textový řetězec, pokud jím není. Podporované primitivní datové typy v~rámci konfiguračních souborů jsou následující:

\begin{itemize}
	\item booleovské hodnoty,
	\item celá čísla,
	\item desetinná čísla,
	\item hodnoty výčtového typu (tzv. enum),
	\item řetězce.
\end{itemize}

Složeným datovým typem z~pohledu použitých konfiguračních souborů může být buď homogenní pole, nebo jiný objekt. Tím pádem vzniká hierarchická datová struktura, která může mít teoreticky nekonečný počet vnořených úrovní. V~praxi je samozřejmě počet úrovní vždy konečný. Důležité ovšem je, aby použitý formát umožňoval reprezentovat libovolný počet vnoření.

Na obrázku~\ref{img:data_tree} je znázorněna hierarchická struktura složeného datového typu \textit{OutputStream}. Pro názornost jsou vynechány některé atributy. Datový typ \textit{OutputStream} obsahuje řetězec \texttt{file}, což je primitivní datový typ. Dále obsahuje pole desetinných čísel \texttt{time\_list}, které dále obsahuje konkrétní desetinná čísla. Posledním znázorněným atributem objektu \textit{OutputStream} je \texttt{format}, který obsahuje referenci na objekt typu \textit{vtk}. Objekt tohoto typu pak dále obsahuje atributy \texttt{variant} a~\texttt{parallel}, což jsou primitivní datové typy.

\includeimg{data_tree}{Příklad složeného datového typu s~různými typy atributů}

\clearpage

\section{Formát pro výměnu dat}

\subsection{Formát CON}

Ve verzi Flow123d~1.8.2 se pro reprezentaci výše popsané datové struktury používá speciální formát \gls{CON}, který byl navržen vývojáři Flow123d pro účel zápisu konfiguračních souborů. Jedná se o~formát, který vychází z~\gls{JSON}, který je specifikován standardem ECMA-404~\cite{bib:ecma404}. Oproti tomuto standardu se liší v~několika detailech.

Příklad části konfiguračního souboru ve formátu \gls{CON} je znázorněn na obrázku~\ref{img:conf_files}. Jednou z~ihned zřejmých odlišností od formátu \gls{JSON} je použití znaku \uv{\texttt{=}} místo \uv{\texttt{:}} pro oddělení klíče a~hodnoty. Dále není nutné psát názvy klíčů do uvozovek. Další odlišnosti a~kompletní specifikaci formátu \gls{CON} lze nalézt v~dokumentaci k~Flow123d~1.8.2~\cite{bib:flow123d-manual}.

Během používání tohoto formátu se ale jeho odlišnost od \gls{JSON} projevila jako jeden z~nedostatků. Kvůli nekompatibilitě s~formátem \gls{JSON} nelze použít pro zpracování formátu \gls{CON} standardní knihovny. To je jeden z~důvodů, proč bylo rozhodnuto, že ve verzi Flow123d~2.0 bude použit nějaký standardní formát pro výměnu dat.

To však nebylo jediným nedostatkem tohoto formátu. Uživatelé, kteří tento soubor upravovali, naráželi často na dva problémy. Bylo pro ně velice nepohodlné neustále kontrolovat správné uzávorkování objektů nebo zda na konci řádku nebyla vynechána čárka pro oddělení položek. To představovalo problém  obzvlášť u~rozsáhlejších konfiguračních souborů, které obsahují hodně úrovní vnoření. Jelikož formát \gls{JSON} sdílí tyto nedostatky, tak byl zavržen jako možný nástupce formátu \gls{CON}.

\subsection{Formát XML}

\gls{XML} je rozšiřitelný značkovací jazyk, který slouží pro popis dat. Tento jazyk vznikl z~jazyka \gls{SGML}~\cite{bib:sgml-iso}, z~kterého je odvozen i~jazyk \gls{HTML}. Všechny správně zformátované \gls{XML} dokumenty jsou zároveň i~\gls{SGML} dokumenty. Popis a~doporučení týkající se jazyka \gls{XML} lze nalézt na webových stránkách \gls{W3C}~\cite{bib:xml}.

\begin{figure}[H]
\singlespacing
\subsubsection*{Soubor ve formátu CON}
\begin{lstlisting}
output = {
  output_stream = {
    file = "./flow_test16.pvd", 
    format = {
      TYPE = "vtk", 
      variant = "ascii"
    }, 
    name = "flow_output_stream"
  }, 
  output_fields = [ "pressure_p0",
                    "pressure_p1", 
                    "velocity_p0" ]
}
\end{lstlisting}

\subsubsection*{Soubor ve formátu XML}
\begin{lstlisting}
<output>
  <output_stream>
  	<file>./flow_test16.pvd</file>
  	<format type="vtk">
  	  <variant>ascii</variant>
  	</format>
  	<name>flow_output_stream</name>
  </output_stream>
  <output_fields>pressure_p0</output_fields>
  <output_fields>pressure_p1</output_fields>
  <output_fields>velocity_p0</output_fields>
</output>
\end{lstlisting}

\subsubsection*{Soubor ve formátu YAML}
\begin{lstlisting}
output:
  output_stream:
  	file: ./flow_test16.pvd
  	format: !vtk
  	  variant: ascii
  	name: flow_output_stream
  output_fields:
    - pressure_p0
    - pressure_p1
    - velocity_p0
\end{lstlisting}
\onehalfspacing
\caption{Ukázky různých formátů pro zápis konfiguračního souboru}
\label{img:conf_files}
\end{figure}

Použití jazyka \gls{XML} pro zápis konfiguračních souborů bylo jednou ze zvažovaných možností. Ukázku takového zápisu lze vidět na obrázku~\ref{img:conf_files}, na němž si lze zároveň všimnout odlišností zápisu formátu XML oproti formátům \gls{CON} a~\gls{YAML}. 

Velkou výhodou tohoto jazyka je, že umožňuje nadefinovat si vlastní strukturu dokumentu. Lze tedy specifikovat kde se mohou vyskytnout jaké elementy, jaké mohou mít atributy a~tak podobně. K~tomu slouží \gls{DTD} nebo \gls{XML} Schema, které má oproti \gls{DTD} více funkcí, např. dokáže omezit počet výskytů elementů.

Použití \gls{XML} Schema by velice usnadnilo validaci datové struktury a~navíc existuje celá řada nástrojů, které jsou schopné ověřit, zda je daný \gls{XML} dokument validní pro dané \gls{XML} Schema. Úskalím použití této validace by však byly tzv. autokonverze, které jsou popsány v~kapitole~\ref{sec:analyza-autokonverze}. Jedná se o~speciální zápis, který lze použít v~datové struktuře při zapisování polí nebo záznamů. V~těchto speciálních případech lze místo pole či záznamu zapsat přímo hodnotu. To znemožňuje běžnou validaci pomocí XML Schema a~bylo by nutné validaci \gls{XML} upravit tak, aby byla schopná brát ohled na autokonverze. To znamená, že by bohužel nebylo možné použít univerzální nástroje pro validaci \gls{XML}.

Nevýhodou formátu \gls{XML} je jeho \uv{vý\-řeč\-nost}. Té si lze na první pohled všimnout na obrázku~\ref{img:conf_files}. Formát \gls{XML} vyžaduje z~uvedených možností pro zápis stejných dat nejvíce znaků. Hlavní nevýhodu v~použití formátu \gls{XML} pro zápis konfiguračních souborů ovšem viděli vývojáři Flow123d jinde. Dle jejich názoru by odlišnost v~zápisu formátu \gls{XML} od formátu \gls{CON} byla pro uživatele Flow123d příliš velkou změnou.

\subsection{Formát YAML}
\label{sec:problematika-format-yaml}

Poslední z~uvažovaných možností bylo použití formátu \gls{YAML}, který je zobecněním formátu \gls{JSON}. Kterýkoliv \gls{JSON} dokument je tím pádem i~\gls{YAML} dokumentem. Oproti formátu \gls{JSON} ovšem formát \gls{YAML} umožňuje syntaktický zápis, který byl speciálně navržen s~ohledem na to, aby ho mohli jednoduše zapisovat lidé.

Toho si lze všimnout opět na obrázku~\ref{img:conf_files}. Ze všech uvedených možností je zápis v~jazyce YAML nejkratší, a~to jak počtem napsaných řádek, tak i~počtem potřebných znaků. Zároveň i~elegantně řeší problémy původně použitého formátu \gls{CON}, resp. formátu \gls{JSON}.

Jelikož se pro zápis vnořených dat používá odsazení, není nadále nutné používat závorky pro ohraničení záznamů a~polí. Dále podporuje zápis polí pomocí odrážek, což je dobře čitelné a~pohodlné pro zápis. Oproti formátu \gls{JSON} také odpadá nutnost psaní čárek na koncích řádků pro oddělení klíčů v~záznamech nebo položek v~poli. Dále není nutné psát řetězce do uvozovek, protože se datové typy rozlišují implicitně.\footnote{V případě potřeby lze datový typ specifikovat i~explicitně, viz kapitola~\ref{sec:analyza-yaml-zapis-datovych-typu}.}

Všechna tato vylepšení vedou k~tomu, že soubory zapsané ve formátu \gls{YAML} jsou velice dobře čitelné a~jednoduché pro zápis. Navíc se formát \gls{YAML} od původního formátu \gls{CON} neliší natolik, jako formát \gls{XML}. To vedlo k~rozhodnutí, že ve verzi Flow123d~2.0 bude použit jazyk \gls{YAML} pro zápis konfiguračních souborů.

Aplikace editoru konfiguračních souborů vytvářená v~rámci diplomové práce tedy bude pracovat s~konfiguračními soubory napsanými ve formátu \gls{YAML}. Aplikace bude zároveň podporovat i~import dříve používaného formátu \gls{CON} a~jeho převod do formátu \gls{YAML}.\footnote{Import formátu CON je nad rámec této diplomové práce a~v~rámci projektu ho řešil Ing. Pavel Richter.} Podpora exportu do formátu \gls{CON} se neplánuje.


\chapter{Analýza}

Tato kapitola se skládá ze tří hlavních částí. V~první z~nich je popsán formát \gls{YAML}, proces jeho zpracování a~jeho základní syntaxe. Druhá část kapitoly rozebírá specifikaci konfiguračních souborů, která je stěžejní pro validaci datové struktury, generování kontextové nápovědy a~funkci automatického doplňování textu. Poslední část popisuje autokonverze, což jsou speciální zkrácené typy zápisů, které se používají v~konfiguračních souborech a~mají zásadní dopad na zpracování datové struktury.


\section{Formát YAML}
Jak již bylo zmíněno v~kapitole~\ref{sec:problematika-format-yaml}, pro zápis konfiguračních souborů se bude používat formát \gls{YAML}. Jedná se o~univerzální formát pro serializaci dat založený na kódování Unicode. Je navržen pro jednoduchý zápis polí, hashovacích tabulek a~primitivních hodnot.

Mezi cíle formátu \gls{YAML} patří mimo jiné jednoduchá čitelnost a~přenositelnost, což jsou pro konfigurační soubory ideální vlastnosti. Dalším z~cílů je čtení pomocí jediného průchodu, což s~sebou oproti formátu \gls{CON} přináší určité komplikace a~změny, které jsou dále rozvedeny v~kapitole~\ref{sec:navrh-yaml-reference}.

\subsection{Proces zpracování souboru}
\label{sec:analyza-proces-zpracovani-yaml}
Jelikož je formát \gls{YAML} navržen tak, aby k~jeho přečtení a~reprezentaci stačil jediný průchod, je možné ho zpracovávat dvěma způsoby. Buď je možné data zpracovávat proudově a~generovat seznam událostí, nebo lze přečíst celý soubor a~vytvořit z~něj datovou reprezentaci.

Oficiální dokumentace formátu \gls{YAML}~\cite{bib:yaml} popisuje proces zpracování, ve kterém se využijí oba výše zmíněné způsoby, které se liší hlavně úrovní abstrakce. Na obrázku~\ref{img:yaml} lze vidět proces zpracování formátu \gls{YAML}.

\includeimg{yaml}{Zpracování formátu YAML}

Proces načtení souboru ve formátu \gls{YAML} prochází třemi fázemi. V~první fázi proběhne lexikální analýza, která převede vstupní soubor na posloupnost událostí. Lexikální analýza hledá symboly a~hodnoty na základě syntaxe \gls{YAML}, kontroluje správné odsazení a~vypustí ze vstupu komentáře.

V~druhé fázi proběhne kompozice, která převede posloupnost událostí na reprezentaci dat pomocí grafu. V~této fázi se z~dat odstraní kotvy a~aliasy se nahradí příslušnými daty. Použití kotev a~aliasů je dále vysvětleno v~kapitole~\ref{sec:navrh-yaml-reference}.

V~poslední fázi se převede graf reprezentující data na datovou strukturu dané aplikace. Tato fáze představuje rozhraní mezi abstrakcí aplikace a~procesem zpracování souboru v~souborovém formátu \gls{YAML}.

V~každé fázi se ztratí část informace. Ve výsledné datové struktuře například nejsou žádné informace o~jejich pozici v~původním textovém souboru. Také nelze určit, zda byla konkrétní data v~souboru zapsána, nebo zda vznikla pouhým odkazem na již existující data z~jiné části souboru.

Formát \gls{YAML} je takto navržen záměrně za účelem oddělení prezentace dat od jejich významu. Pro potřeby aplikace \textit{ModelEditor} je ovšem tato vlastnost nežádoucí. Například informace o~pozici hodnoty v~konfiguračním souboru je podstatná a~dále se využívá pro některé funkce. Touto problematikou se zabývá kapitola~\ref{sec:implementace-yaml}.

\subsection{Zápis datových typů}
\label{sec:analyza-yaml-zapis-datovych-typu}

\subsubsection*{Skalární hodnoty}

Formát \gls{YAML} podporuje několik skalárních datových typů, které jsou dále nedělitelné. Jedná se o~celá a~desetinná čísla, booleovské hodnoty a~znakové řetězce. Zápis těchto hodnot je velice intuitivní. 

Celá čísla se zapisují pomocí běžné konvence v~desítkové soustavě. Dále je možné je zapsat v~šestnáctkové nebo osmičkové soustavě pomocí prefixu \texttt{0x}, resp \texttt{0o}. Desetinná čísla se zapisují s~desetinnou tečkou a~dále je pro jejich zápis možné použít i~věděckou notaci. Booleovské hodnoty se zapisují jako \texttt{true} a~\texttt{false}, kde první písmeno může být velké, případně mohou být velká i~všechna písmena zároveň.

\vspace{8pt}
\begin{tabular}{m{5cm}@{}l}
\textit{celá čísla}\dotfill & \texttt{0, 0o7, 0x3A, -19} \\
\textit{desetinná čísla}\dotfill & \texttt{0., -0.0, .5, +12e03, -2E+05, .inf, .NaN}  \\
\textit{booleovské hodnoty}\dotfill & \texttt{true, True, false, FALSE}\\
\end{tabular}
\vspace{8pt}

Řetězce se zapisují jako sekvence znaků, které není třeba psát do uvozovek ani pokud obsahují mezery nebo zalomení řádků. Pokud by řetězec obsahoval speciální znak, jako je třeba dvojtečka, která se používá na oddělení klíče od hodnoty, tak musí být řetězec napsán do uvozovek.

Všechny tyto zápisy skalárních hodnot jsou popsány v~dokumentaci YAML~\cite{bib:yaml} pomocí regulárních výrazů. Během fáze kompozice se na základě těchto regulárních výrazů určí implicitní datový typ proměnné, který se použije, pokud není explicitně zadán jiný datový typ. Datový typ lze explicitně zadat pomocí tzv. tagu. Dokumentace \gls{YAML} definuje následující tagy pro skalární datové typy.

\vspace{8pt}
\begin{tabular}{m{5cm}@{}l}
\textit{celá čísla}\dotfill & \texttt{!!int} \\
\textit{desetinná čísla}\dotfill & \texttt{!!float}  \\
\textit{booleovské hodnoty}\dotfill & \texttt{!!bool}\\
\textit{řetězec}\dotfill & \texttt{!!str} \\
\end{tabular}
\vspace{8pt}

Pokud je potřeba explicitně zadat datový typ, píše se tento tag před samotnou hodnotu a~odděluje se od ní mezerou. Následuje seznam ukázek zápisu hodnot a~příslušných datových typů, na které budou převedeny.

\vspace{-2pt}
\setlength\LTleft\parindent
\begin{longtable}{m{5cm}@{}l}
\texttt{0}\dotfill & \textit{celé číslo} \\
\texttt{!!float 0}\dotfill & \textit{desetinné číslo} \\
\texttt{"0"}\dotfill & \textit{řetězec} \\
\texttt{!!str 0}\dotfill & \textit{řetězec} \\
\texttt{true}\dotfill & \textit{booleovská hodnota} \\
\texttt{!!str true}\dotfill & \textit{řetězec} \\
\end{longtable}
\vspace{-15pt}

\subsubsection*{Sekvence}

Sekvence se používají pro reprezentaci polí. Formát \gls{YAML} podporuje dva způsoby zápisu sekvencí. Lze je zapsat buď zjednodušeně\footnote{Angl. \textit{flow style} -- zde označován jako \textit{zjednodušený zápis}.} nebo blokově pomocí odrážek. Zjednodušený zápis sekvencí je totožný se zápisem polí ve formátu \gls{JSON} a~vypadá následovně.

\lstset{style=short}

\vspace{5pt}
\begin{lstlisting}
[1, 2, 3]
\end{lstlisting}
\vspace*{-20pt}

Pro blokový zápis se používá znak \texttt{-} (spojovník) jako odrážka, která musí být následována alespoň jednou mezerou a~poté samotnou položkou sekvence. Každá odrážka musí být na samostatném řádku a~odsazení všech položek sekvence musí být stejné. Zápis sekvence pomocí odrážek může vypadat například následovně.

\vspace{5pt}
\begin{lstlisting}
- 1
- 2
- 3
\end{lstlisting}
\vspace*{-20pt}

V~rámci jednoho dokumentu lze používat oba typy zápisů sekvencí. V~rámci jedné sekvence však musí být dodržena stejná syntaxe. Sekvence lze do sebe vnořovat do libovolné úrovně.

\subsubsection*{Mapy}

Mapy se ve formátu \gls{YAML} používají pro zápis dvojic klíč a~hodnota -- jedná se tedy o~hashovací tabulku. Mapy lze obdobně jako sekvence zapsat buď zjednodušeně nebo blokově. Zjednodušený zápis se opět podobá formátu \gls{JSON}.

\vspace{5pt}
\begin{lstlisting}
{a: 1, b: 2}
\end{lstlisting}
\vspace*{-20pt}

Blokový zápis vyžaduje, aby každý klíč byl na novém řádku. Při použití blokového zápisu opět závisí na odsazení, které musí být jednotné v~rámci celé mapy. Blokový zápis může vypadat například následovně.

\vspace{5pt}
\begin{lstlisting}
a: 1
b: 2
\end{lstlisting}
\vspace*{-20pt}

V~rámci dokumentu lze opět používat oba typy zápisů map a~v~rámci jedné mapy musí být dodržena jednotná syntaxe. Mapy i~seznamy lze do sebe vzájemně vnořovat do libovolné úrovně.

\section{Specifikace formátu konfiguračních souborů}

Simulátor Flow123d umožňuje exportovat popis datové struktury konfiguračních souborů. Tento popis struktury bude v~textu nadále označován jako \textit{specifikace formátu}. Oproti tomu slovo \textit{formát} udává použitou textovou reprezentaci pro zápis konfiguračního souboru -- nejčastěji tedy označuje buď souborový formát \gls{YAML} nebo starší formát \gls{CON}.

Zatímco formát udává syntaktická pravidla pro vytváření konfiguračních souborů, specifikace formátu popisuje sémantický význam zapsaných dat, definuje použitelné uživatelské typy a~klade různá omezení na vstupní datovou strukturu. Formát a~specifikaci formátu lze považovat za analogii k~\gls{XML}, resp. \gls{XML} Schema.

Mezi vývojáři Flow123d se specifikace formátu také označuje jako \gls{IST}. S~tím, jak se vyvíjí nová a~rozšiřuje stávající funkcionalita simulátoru Flow123d, se mění i~tato specifikace formátu. Z~toho plyne zásadní požadavek na validaci konfiguračních souborů -- \textbf{proces validace musí být možné přizpůsobit konkrétní specifikaci formátu, která je závislá na verzi Flow123d}.

Specifikace formátu je generována simulátorem Flow123d na základě jeho interní datové struktury. Reprezentace této struktury je exportována do formátu \gls{JSON}. Tato specifikace formátu obsahuje kromě požadavků na datovou strukturu i~dokumentační řetězce, ze kterých se vytváří referenční dokumentace. Specifikace formátu je tedy úplným popisem datové struktury konfiguračních souborů, ze kterého vychází hlavní funkce \textit{ModelEditoru}, jako je validace konfiguračních souborů, generování kontextové nápovědy nebo automatické doplňování textu.

\subsection{Základní datové typy}
\label{sec:analyza-specifikace-formatu-zakladni-datove-typy}
Jak již bylo zmíněno v~kapitole \ref{sec:datova-struktura}, konfigurační soubory obsahují hierarchickou datovou strukturu, která tvoří strom. Specifikace formátu definuje datový typ pro každý uzel stromu, ať už se jedná o~interní uzel nebo list stromu. Datové typy definované ve specifikaci formátu mohou mít následující parametry:

\vspace{0.5cm}
\begin{tabular}{m{3cm}@{}l}
\texttt{id}\dotfill & unikátní řetězec označující datový typ \\
\texttt{input\_type}\dotfill & základní typ, ze kterého je datový typ odvozen  \\
\texttt{name}\dotfill & název datového typu (nemusí být unikátní) \\
\texttt{description}\dotfill & dokumentační řetězec popisující datový typ \\
\texttt{attributes}\dotfill & pomocné atributy obsahující dodatečné informace \\
\end{tabular}
\vspace{0.5cm}

Základní typ \texttt{input\_type} udává pouze typ, ze kterého je konkrétní datový typ odvozen. Konkrétní datové typy obsahují výše vyjmenované informace a~případná další upřesnění či omezení. Specifikace formátu může takových datových typů definovat neomezený počet. Oproti tomu je možné využít pouze následující základní datové typy:

\begin{itemize}[itemsep=2pt, topsep=12pt, partopsep=0pt]
\item \textit{Integer} pro celá čísla,
\item \textit{Double} pro reálná čísla,
\item \textit{String} pro řetězce,
\item \textit{Filename} pro jména souborů,
\item \textit{Selection} pro výčtové typy,
\item \textit{Array} pro homogenní pole,
\item \textit{Record} pro záznamy,
\item \textit{Abstract} pro abstraktní záznamy.
\end{itemize}

\subsection{Primitivní datové typy}

Mezi tyto datové typy patří všechny typy odvozené z~\textit{Integer}, \textit{Double}, \textit{String}, \textit{Filename} nebo \textit{Selection}. Jedná se o~datové typy, jejichž hodnota je z~pohledu datové struktury konfiguračního souboru dále nedělitelná. Ve stromové datové struktuře se tedy vždy jedná o~listy stromu.

Datové typy odvozené z~\textit{Filename} a~\textit{String} nemají v~současné verzi Flow123d žádné další parametry, které by omezovaly jejich možné hodnoty (např. omezení délky řetězce). Datové typy, které slouží pro reprezentaci čísel, tedy typy odvozené od \textit{Integer} a~\textit{Double}, mohou mít navíc omezený rozsah povolených hodnot pomocí zadání intervalu \texttt{range}.

\vspace{0.5cm}
\begin{tabular}{m{3cm}@{}l}
\texttt{range}\dotfill & dvojice čísel, která vymezuje rozsah platných hodnot \\
\end{tabular}
\vspace{0.5cm}

Datové typy odvozené z~typu \textit{Selection} slouží pro specifikaci výčtového typu. Tyto typy mají pevně definovanou množinu platných hodnot, která je zadána pomocí parametru \texttt{values}. Každý záznam v~tomto poli je definován pomocí jejich názvu \texttt{name} a~popisu \texttt{description}.


\vspace{0.5cm}
\begin{tabular}{m{3cm}@{}l}
\texttt{values}\dotfill & seznam přípustných hodnot včetně jejich popisu \\
\end{tabular}

\subsection{Pole}

Všechna pole ve specifikaci datové struktury jsou homogenní -- obsahují tedy prvky, které jsou stejného datového typu (případně jsou odvozeny ze stejného abstraktního datového typu, viz dále). Datový typ potomků pole definuje parametr \texttt{subtype}, který obsahuje identifikátor datového typu. Pole dále mohou obsahovat omezení minimálního a~maximálního počtu prvků, zadaného pomocí \texttt{range}.

\vspace{0.5cm}
\begin{tabular}{m{3cm}@{}l}
\texttt{range}\dotfill & dvojice čísel udávající minimální a~maximální počet prvků \\
\texttt{subtype}\dotfill & datový typ jednotlivých prvků pole \\
\end{tabular}

\subsection{Záznamy}

Záznamy slouží pro inicializaci tříd a~jejich atributy tvoří dvojice klíč a~hodnota. Každý datový typ odvozen z~typu \textit{Record} má v~rámci specifikace formátu definován množinu klíčů \texttt{keys}. Dále mohou mít záznamy definován parametr \texttt{reducible\_to\_key}, který se používá pro autokonverzi na záznam (viz kapitola \ref{sec:analyza-autokonverze-zaznam}).

\vspace{0.5cm}
\begin{tabular}{m{4cm}@{}l}
\texttt{keys}\dotfill & definuje množinu klíčů daného záznamu \\
\texttt{reducible\_to\_key}\dotfill & obsahuje název klíče použitého pro autokonverzi \\
\end{tabular}
\vspace{0.5cm}

Definice každého klíče dále obsahuje další parametry. Mezi ně patří \texttt{key}, který udává název klíče, poté opět popis \texttt{description}, datový typ klíče \texttt{type} a~parametr \texttt{default}.

\vspace{0.5cm}
\begin{tabular}{m{4cm}@{}l}
\texttt{key}\dotfill & název klíče \\
\texttt{description}\dotfill & dokumentační řetězec popisují klíč záznamu \\
\texttt{type}\dotfill & identifikátor očekávaného datového typu klíče \\
\texttt{default}\dotfill & upřesňuje typ klíče a~případně jeho výchozí hodnotu \\
\end{tabular}
\vspace{0.5cm}

Parametr \texttt{default} se skládá z~dvojice parametrů \texttt{type} a~\texttt{value}. Parametr \texttt{value} udává výchozí hodnotu klíče. Tato hodnota se použije v~případě, že se v~konfiguračním souboru nevyskytne daný klíč. Parametr \texttt{type} udává, zda je potřeba klíč explicitně zadat či nikoliv a~může nabývat následujících hodnot.

\begin{longtable}{m{4cm}@{}l}
\textit{obligatory}\dotfill & klíč je povinný a~jeho hodnota musí být explicitně zadána \\
\textit{optional}\dotfill & klíč je nepovinný a~nemá žádnou výchozí hodnotu \\
\textit{value at declaration}\dotfill & výchozí hodnota je součástí deklarace typu \\
\textit{value at run time}\dotfill & výchozí hodnota se načte při spuštění \\
\end{longtable}

Z~pohledu aplikace \textit{ModelEditor} je podstatná pouze hodnota \textit{obligatory}, která udává, že klíč musí být v~konfiguračním souboru uveden. Ostatní typy klíčů nemusí být v~konfiguračním souboru explicitně uvedeny. Pokud se však objeví, provede se jejich validace jako stejně jako u~ostatních klíčů.

\subsection{Abstraktní záznamy}
\label{sec:analyza-specifikace-formatu-abstraktni-zaznamy}

Posledním speciálním typem, který se používá ve struktuře konfiguračních souborů je abstraktní záznam. Jedná se o~všechny typy, které jsou odvozené ze základního typu označovaného jako \textit{Abstract}. Abstraktní záznamy slouží jako zástupný typ, který se ve specifikaci formátu datové struktury objevuje na místech, kde se mohou vyskytovat různé typy (ovšem ne zcela libovolné).

Jeden z~příkladů využití je při výběru typu simulovaného procesu. Existuje několik typů procesů, které Flow123d dokáže řešit. Jednotlivé procesy se však liší a~tím pádem i~vyžadují jiné parametry a~data mají odlišnou strukturu.
V~místě, kde se zadává proces očekává specifikace formátu abstraktní záznam.
V~konfiguračním souboru se na daném místě uvede konkrétní záznam, který implementuje očekávaný abstraktní záznam. U~těchto záznamů je ve specifikaci formátu uvedeno, které abstraktní záznamy implementují pomocí klíče \texttt{implements}.

Použitá terminologie se rozchází s~programátorskou terminologií, kde by se tento abstraktní záznam označil spíše jako rozhraní. Abstraktní záznamy totiž nemohou mít definované žádné klíče -- tím pádem se nepoužívají pro dědičnost. Navíc jeden konkrétní typ může implementovat více abstraktních typů, což je z~pohledu objektového programování typické spíše pro rozhraní. Pro zachování jednotné terminologie se specifikací formátu Flow123d a~její dokumentací bude ale nadále tento typ označován jako abstraktní záznam.

\vspace{0.5cm}
\begin{tabular}{m{5cm}@{}l}
\texttt{default\_descendant}\dotfill & výchozí typ abstraktního záznamu \\
\texttt{implementations}\dotfill & seznam implementací abstraktního záznamu \\
\end{tabular}
\vspace{0.5cm}

Jak již bylo řečeno, oproti záznamům neobsahují abstraktní záznamy žádnou definici klíčů. Obsahují však navíc parametr \texttt{default\_descendant}, který udává identifikátor datového typu, který se použije v~případě, že záznam, který je uveden na místě, kde se očekává abstraktní záznam, nemá explicitně uvedený typ. Abstraktní záznam navíc obsahuje parametr \texttt{implementations}, který obsahuje seznam identifikátorů všech jeho implementací. Jedná se o~duplicitní informaci a~v~rámci aplikace \textit{ModelEditor} není využita, protože se využívá výše zmíněný parametr \texttt{implements}.


\section{Autokonverze}
\label{sec:analyza-autokonverze}

V~konfiguračních souborech pro Flow123d se používají speciální zápisy záznamů a~polí, které vývojáři a~uživatelé Flow123d označují jako automatické konverze, nebo zkráceně pouze autokonverze. Cílem autokonverzí je zjednodušení a~zkrácení zápisu.

Pomocí autokonverzí lze například vynechat definici typu a~klíče a~místo toho zapsat pouze hodnotu. Zápis se tím výrazně zkrátí, ale zároveň to způsobí značné komplikace z~pohledu validace konfiguračního souboru nebo určení přesné polohy v~rámci datové struktury. Situace se dále komplikuje tím, že je možné použít vnořené autokonverze -- tedy provést autokonverzi v~rámci jiné autokonverze.

Logika autokonverzí je zhruba následující. Pokud datový typ neodpovídá o\-če\-ká\-va\-né\-mu datovému typu dle specifikace formátu, zkusí se provést některá z~autokonverzí, pokud je na tomto místě použitelná. V~případě, že po autokonverzi již datový typ odpovídá očekávanému datovému typu, tak se datová struktura dále prochází do hloubky, kde může dojít k~případným dalším autokonverzím.

Autokonverze jsou hlavní důvodem, proč není možné použít \gls{XML} Schema a~souborový formát \gls{XML} pro validaci konfiguračních souborů. Kvůli autokonverzím by nebylo možné pouze triviálně použít nástroj pro validaci \gls{XML} schématu k~validaci konfiguračního souboru.

Autokonverze mohou působit poněkud chaoticky, protože datová struktura obsahuje ve skutečnosti něco jiného, než je zapsáno v~konfiguračním souboru. Zkušení uživatelé Flow123d jsou ovšem zvyklí autokonverze používat a~jsou pro ně přínosem. S~přechodem na nový formát konfiguračního souboru se funkcionalita autokonverzí zachovává.

Aplikace \textit{ModelEditor} tedy musí podporovat používání autokonverzí a~je nutné je zohlednit při validaci konfiguračních souborů a~určování pozice v~rámci datového stromu, která je dále použita pro funkce kontextové nápovědy nebo automatického doplňování textu. 

Používají se tři základní typy autokonverzí, které jsou dále popsány. Kromě doposud používaných autokonverzí na pole a~na záznam přibyla i~nová autokonverze, která se nazývá transpozice. Transpozice zobecňuje a~rozšiřuje současně používanou autokonverzi na pole.

\subsection{Autokonverze na pole}
\label{sec:analyza-autokonverze-pole}

\lstset{style=short}

Autokonverze na pole je konverze, která se použije, pokud se dle specifikace formátu na dané pozici v~datové struktuře očekává pole (typ \textit{Array}) a~místo něj je nalezen libovolný jiný datový typ -- ať už se jedná o~primitivní datový typ nebo o~záznam.

\begin{figure}[ht]
\begin{minipage}[t]{0.45\linewidth}
\vspace{0pt}
\textbf{Zapsaná datová struktura}\\
\vspace{-5pt}
\begin{lstlisting}
value: 2.5
\end{lstlisting}
\vspace*{-20pt}
\begin{center}
\includegraphics[height=120pt]{../img/autoconversion_array_1_before.pdf}
\end{center}
\end{minipage}
\quad
\begin{minipage}[t]{0.45\linewidth}
\vspace{0pt}
\textbf{Skutečná datová struktura}\\
\vspace{-5pt}
\begin{lstlisting}
value: [2.5]
\end{lstlisting}
\vspace*{-20pt}
\begin{center}
\includegraphics[height=190pt]{../img/autoconversion_array_1_after.pdf}
\end{center}
\end{minipage}
\caption{Autokonverze na jednorozměrné pole}
\label{img:autoconversion_array_1}
\end{figure}	

Obrázek~\ref{img:autoconversion_array_1} znázorňuje autokonverzi hodnoty na jednorozměrné pole. V~klíči \texttt{value} v~záznamu \textit{FieldConstant} se očekává jednorozměrné pole, ale místo něj se na dané pozici vyskytla hodnota \texttt{2.5}. Provede se tedy autokonverze na pole a~poté skutečná datová struktura obsahuje jednorozměrné pole o~jednom prvku, kterým je právě tato hodnota.

Autokonverze na pole funguje obdobně i~pro vícerozměrná pole. Příklad této autokonverze je uveden na obrázku~\ref{img:autoconversion_array_2}. Klíč \texttt{value} v~záznamu \textit{FieldConstant} má nyní být dvourozměrné pole.\footnote{Přes to, že tento záznam má opět název \textit{FieldConstant}, jedná se o odlišný typ záznamu od předchozího příkladu. První z nich byl implementací abstraktního záznamu \textit{Field:R3 $\rightarrow$ R}, zatímco druhý implementuje \textit{Field:R3 $\rightarrow$ R[3,3]}.} Místo toho se v~datové struktuře vyskytla hodnota. Ta se zkonvertuje na dvourozměrné pole, jehož jediným prvek je právě tato hodnota.

Autokonverze na vícerozměrné pole proběhne i~v~případě, pokud je v~datové struktuře pole o~menší dimenzi, než se očekává. Pokud takový případ nastane, tak se zadané pole zkonvertuje na pole vyšší dimenze obdobně jako to bylo popsáno u~konverzí hodnot na pole.

\begin{figure}[ht]
%\vspace{10pt}
\begin{minipage}[t]{0.45\linewidth}
\vspace{0pt}
\textbf{Zapsaná datová struktura}\\
\vspace{-5pt}
\begin{lstlisting}
value: 1.5
\end{lstlisting}
\vspace*{-20pt}
\begin{center}
\includegraphics[height=120pt]{../img/autoconversion_array_2_before.pdf}
\end{center}
\end{minipage}
\quad
\begin{minipage}[t]{0.45\linewidth}
\vspace{0pt}
\textbf{Skutečná datová struktura}\\
\vspace{-5pt}
\begin{lstlisting}
value: [[1.5]]
\end{lstlisting}
\vspace*{-20pt}
\begin{center}
\includegraphics[height=250pt]{../img/autoconversion_array_2_after.pdf}
\end{center}
\end{minipage}
\caption{Autokonverze na vícerozměrné pole}
\label{img:autoconversion_array_2}
\end{figure}	

\subsection{Autokonverze na záznam}
\label{sec:analyza-autokonverze-zaznam}

Autokonverze na záznam se provádí v~případě, že se v~datové struktuře na dané pozici očekává záznam\footnote{Záznam je datový typ, který je odvozený ze základního typu \textit{Record} nebo \textit{Abstract}, viz dále.} a~místo něj se v~datové struktuře nachází pole či primitivní datový typ. Oproti autokonverzi na pole, která proběhne vždy, musí být autokonverze na záznam explicitně povolena ve specifikaci formátu pro daný záznam.

Záznam musí mít ve specifikaci formátu uvedený parametr \texttt{reducible\_to\_key}, který udává, do kterého klíče se má nalezená datová struktura vložit. Pokud tento parametr není uveden, tak záznam autokonverzi nepodporuje a~nelze ji provést.

\begin{figure}[ht]
\begin{minipage}[t]{0.45\linewidth}
\vspace{0pt}
\textbf{Zapsaná datová struktura}\\
\vspace{-5pt}
\begin{lstlisting}
balance: true

\end{lstlisting}
\vspace*{-20pt}
\begin{center}
\includegraphics[height=120pt]{../img/autoconversion_record_before.pdf}
\end{center}
\end{minipage}
\quad
\begin{minipage}[t]{0.45\linewidth}
%\centering
\vspace{0pt}
\textbf{Skutečná datová struktura}\\
\vspace{-5pt}
\begin{lstlisting}
balance:
  balance_on: true
\end{lstlisting}
\vspace*{-20pt}
\begin{center}
\includegraphics[height=190pt]{../img/autoconversion_record_after.pdf}
\end{center}
\end{minipage}
\caption{Autokonverze na záznam}
\label{img:autoconversion_record}
\end{figure}	

Příklad autokonverze na záznam je znázorněn na obrázku~\ref{img:autoconversion_record}. Záznam \textit{Steady\_MH} obsahuje klíč \texttt{balance}. V~zapsané datové struktuře je pro tento klíč uvedena hodnota \texttt{true}, tedy datový typ \textit{Boolean}. Ovšem podle specifikace formátu se zde očekává záznam typu \textit{Balance}. Jelikož má datový typ \textit{Balance} uveden klíč \texttt{reducible\_to\_key}, který je nastaven na hodnotu \texttt{balance\_on}, tak dojde k~autokonverzi na záznam. Ve skutečné datové struktuře je tedy v~klíči \texttt{balance} záznam typu \textit{Balance}, jehož klíč \texttt{balance\_on} je nastaven na původně uvedenou hodnotu \texttt{true}.

U~záznamů, které podporují tuto autokonverzi, jsou typicky předdefinované výchozí hodnoty klíčů. Uživatel přitom nejčastěji mění právě jeden z~těchto klíčů. Tento klíč je pak ve specifikaci formátu uveden jako \texttt{reducible\_to\_key}. Díky autokonverzi na záznam pak uživatel může měnit hodnotu tohoto klíče bez nutnosti psát název tohoto klíče.

Existuje speciální případ této autokonverze, kdy se podle specifikace formátu očekává v~datové struktuře abstraktní záznam. Abstraktní záznamy samy o~sobě nepodporují autokonverzi na záznam. Pokud ovšem mají definovaný klíč \texttt{default\_de\-scend\-ant}, který udává výchozí typ záznamu, je možné provést autokonverzi, pokud ji daný záznam podporuje.

\subsection{Transpozice}
\label{sec:analyza-autokonverze-transpozice}
Transpozice je nově přidaná autokonverze, která umožňuje definovat pole záznamů najednou pomocí speciálního zápisu pro jeden záznam. Transpozice může výrazně zkrátit zápis pole záznamů obzvlášť v~případech, kdy záznamy obsahují více klíčů a~mění se pouze hodnoty některých klíčů, zatímco hodnoty ostatních klíčů zůstávají totožné.


\begin{figure}[ht]
\begin{minipage}[t]{0.45\linewidth}
\vspace{0pt}
\textbf{Zapsaná datová struktura}\\
\vspace{-5pt}
\begin{lstlisting}
input_fields:
  region: Region1
  time:
    - 0.5
    - 1.0
\end{lstlisting}
\vspace{-20pt}
\begin{center}
\includegraphics[height=245pt]{../img/autoconversion_transposition_before.pdf}
\end{center}
\end{minipage}
\quad
\begin{minipage}[t]{0.5\linewidth}
\vspace{0pt}
\textbf{Skutečná datová struktura}\\
\vspace{-5pt}
\begin{lstlisting}
input_fields:
  - region: Region1
    time: 0.5
  - region: Region1
    time: 1.0
\end{lstlisting}
\vspace{-20pt}
\begin{center}
\includegraphics[height=245pt]{../img/autoconversion_transposition_after.pdf}
\end{center}
\end{minipage}
\caption{Autokonverze -- transpozice}
\label{img:autoconversion_transposition}
\end{figure}	

Transpozice je speciálním případem autokonverze na pole. Provádí se v~případě, kdy se v~datové struktuře očekává pole záznamů, ale místo něj je nalezen pouze jeden záznam. Pokud nastane tato situace, proběhnou další kontroly, zda je možné transpozici provést (viz kapitola~\ref{sec:navrh-autokonverze}), a~pokud je to možné, tak se zapsaná datová struktura převede následujícím způsobem.

Nejprve se vytvoří pole záznamů, které se očekávalo podle specifikace formátu. Dále se provede expanze polí, kdy se pro každou hodnotu v~poli původně zapsaného záznamu vytvoří samostatný záznam, který se uloží do nově vytvořeného pole záznamů. Během této expanze se do nově vytvořených záznamů vkládají kon\-krétní hodnoty místo původních polí hodnot. Pokud v~daném klíči v~původním záznamu nebylo pole, ale hodnota či jiný záznam, tak se tato hodnota zkopíruje.

Nejjednodušší případ této konverze je znázorněn na obrázku~\ref{img:autoconversion_transposition}. Zde se pomocí transpozice definuje pole \texttt{input\_fields}, které obsahuje záznamy typu \textit{Steady\_MH}. Tento záznam obsahuje klíče \texttt{region} a~\texttt{time}. Zapsaná datová struktura se transponuje tak, že se místo jediného uvedeného záznamu vytvoří pole záznamů o~dvou prvcích, protože pole \texttt{time} obsahuje dvě hodnoty. Každý z~těchto záznamů bude mít klíč \texttt{time} i~\texttt{region}. U~prvního záznamu bude klíč \texttt{time} nastaven na hodnotu~\texttt{0.5}, zatímco u~druhého záznamu bude mít klíč \texttt{time} hodnotu~\texttt{1.0}. Klíč \texttt{region} bude v~obou záznamech nastaven na totožnou hodnotu \texttt{Region1}.

Pokud zapsaný záznam obsahuje více polí, tak jejich expanze probíhá souběžně. První záznam bude tedy obsahovat vždy první prvky z~polí, druhý záznam druhé prvky z~polí atd. To je znázorněno na obrázku~\ref{img:transposition_code_example}. Dále si lze všimnout, že vhodně použitá transpozice může výrazně zkrátit zápis.

\lstset{style=code}

\begin{figure}[ht]
\singlespacing
\begin{minipage}[t]{0.5\linewidth}
\vspace{0pt}
\textbf{Zapsaná datová struktura}\\
\vspace{-5pt}
\begin{lstlisting}
input_fields: 
  region: MyRegion
  bc_type: neumann
  time: [0.5, 1.0, 1.5]
  anisotropy: [2.5, 1.5, 1.8]
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\linewidth}
\vspace{0pt}
\textbf{Skutečná datová struktura}\\
\vspace{-5pt}
\begin{lstlisting}
input_fields: 
  - region: MyRegion
    bc_type: neumann
    time: 0.5
    anisotropy: 2.5
  - region: MyRegion
    bc_type: neumann
    time: 1.0
    anisotropy: 1.5
  - region: MyRegion
    bc_type: neumann
    time: 1.5
    anisotropy: 1.8
\end{lstlisting}
\vspace*{-20pt}
\end{minipage}
\onehalfspacing
\caption{Ukázka použití transpozice}
\label{img:transposition_code_example}
\end{figure}

\chapter{Návrh}

\section{Použití syntaxe YAML}
V~této kapitole je upřesněno použití syntaxe \gls{YAML} pro zápis konfiguračních souborů včetně speciálních případů, které se používaly ve formátu \gls{CON}, jako jsou specifikace typu záznamu a~použití referencí. Dále je popsán proces získání datové struktury z~konfiguračního souboru, který zahrnuje provedení autokonverzí. Kapitola se dále zabývá validací načtené datové struktury. V~poslední části kapitoly jsou navrženy základní komponenty uživatelského rozhraní a~je popsána jejich funkce.

\subsection{Základní použití syntaxe}

Pro reprezentace primitivních datových typů, polí a~záznamů v~konfiguračních souborech lze využít základní syntaxi formátu \gls{YAML} popsanou v~kapitole~\ref{sec:analyza-yaml-zapis-datovych-typu}. Primitivní datové typy lze zapsat s~využitím syntaxe pro skalární hodnoty, pole je možné reprezentovat pomocí syntaxe pro sekvence a~záznamy lze zapsat pomocí syntaxe pro mapy.

Pro reprezentaci polí se doporučuje použít syntaxe pro blokový zápis, kromě případů, kdy je zjednodušený zápis výrazně kratší bez újmy na čitelnosti (např. zápis pole celočíselných hodnot). Pro reprezentaci záznamů se doporučuje používat výhradně syntaxe pro blokový zápis. Zjednodušený zápis záznamů působí chaoticky a~editor nemusí podporovat některé funkce při používání tohoto zápisu.

Formát \gls{YAML} nepředepisuje, jaké by mělo být odsazení při vnořování blokových zápisů, ale pouze vyžaduje, aby bylo v~rámci daného bloku jednotné. V~rámci konfiguračních souborů Flow123d se ale doporučuje používat odsazení pomocí dvou mezer, aby byl styl použitý pro zápis konfiguračních souborů jednotný. Editor je optimalizován na použití odsazení pomocí dvou mezer a~znaky tabulátor automaticky převádí na toto odsazení.

\subsection{Abstraktní záznamy}
\label{sec:navrh-yaml-abstrakni-zaznamy}
Abstraktní záznamy jsou datovým typem, který definuje specifikace formátu. Tyto záznamy mohou mít více různých implementací. V~konfiguračním souboru, kde se podle specifikace formátu očekává abstraktní záznam, musí být uvedena konkrétní implementace. Implementace abstraktního záznamu je záznam, který má v~jeho specifikaci uvedeno, že implementuje daný abstraktní záznam. To bylo popsáno v~kapitole~\ref{sec:analyza-specifikace-formatu-abstraktni-zaznamy}.

Příkladem je třeba klíč \texttt{primary\_equation} v~datovém typu \textit{SequentialCoupling}. Typ klíče \texttt{primary\_equation} je \textit{DarcyFlow}, což je abstraktní záznam. V~současné verzi Flow123d existují tři implementace tohoto záznamu -- \textit{Steady\_MH}, \textit{Unsteady\_MH} a~\textit{Unsteady\_LMH}. To znázorňuje obrázek~\ref{img:abstract_record_darcyflow}.

\begin{figure}[h]
	\centering
    \includegraphics[height=190pt]{../img/abstract_record_darcyflow.pdf}
    \caption{Abstraktní záznam DarcyFlow a~jeho implementace}
	\label{img:abstract_record_darcyflow}
\end{figure}

V~konfiguračním souboru je nutné nějakým způsobem určit, jaká implementace byla zvolena. Formát \gls{CON} toto řešil pomocí speciálního klíče \texttt{TYPE}. Tento klíč obsahoval výběrový typ, který mohl nabývat hodnot, které odpovídaly názvům jednotlivých implementací. Nevýhoda tohoto řešení byla, že klíč \texttt{TYPE} byl uveden v~záznamu jako běžný klíč i~přes to, že pouze určoval datový typ záznamu a~měl jiný význam než ostatní klíče. Ukázka výběru konkrétní implementace ve formátu CON je na obrázku~\ref{img:abstract-record-con} na straně~\pageref{img:abstract-record-con}.

Ve formátu \gls{YAML} existují takzvané tagy, které slouží pro určení datového typu. Jsou definovány některé základní tagy, které se používají pro odlišení typů, které jsou univerzální pro všechny \gls{YAML} dokumenty. Tyto předdefinované tagy byly popsány v~kapitole~\ref{sec:analyza-yaml-zapis-datovych-typu} a~jejich kompletní popis lze nalézt v~dokumentaci formátu \gls{YAML}~\cite{bib:yaml}. Všechny předdefinované tagy začínají \texttt{!!} (dvěma vykřičníky).

Lze ovšem využít i~uživatelsky definované tagy. Ty začínají pouze jedním znakem~\texttt{!}~(vykřičník) a~poté jsou následovány uživatelsky definovaným názvem. Zpracování těchto tagů je potom aplikačně specifické a~řeší se v~rámci procesu načtení \gls{YAML} dokumentu. Použití uživatelsky definovaného tagu může vypadat následovně.

\lstset{style=short}
\vspace{5pt}
\begin{lstlisting}
solver: !Petsc
  a_tol: 1e-12
  r_tol: 1e-12
\end{lstlisting}
\vspace{-20pt}

Uživatelsky definované tagy jsou ideální pro výběr konkrétní implementace abstraktního záznamu. Jejich zápis je jednoznačně odlišuje od ostatních dat v~záznamu a~nejsou potom součástí samotných dat záznamu. Na obrázcích~\ref{img:abstract-record-con} a~\ref{img:abstract-record-yaml} na straně~\pageref{img:abstract-record-con} lze porovnat způsob výběru implementace abstraktního záznamu ve formátech \gls{CON} a~\gls{YAML}.


\subsection{Reference}
\label{sec:navrh-yaml-reference}

Ve formátu \gls{CON} bylo možné se pomocí referencí odkázat na libovolnou část datové struktury. Tento odkaz byl pak při zpracování nahrazen daty, na které odkazoval. Dalo se tak předejít duplicitě dat. Pokud byla některá data totožná s~daty v~jiné části datové struktury, stačilo použít referenci.

Reference se ve formátu \gls{CON} používaly tak, že se do speciálního klíče \texttt{REF} uvedla libovolná cesta do jiné části datové struktury. Ta mohla být buď absolutní nebo relativní a~mohla být v~libovolné části konfiguračního souboru. Ukázka použití reference ve formátu \gls{CON} je na obrázku \ref{img:reference-con} na straně \pageref{img:reference-con}.

Formát \gls{YAML} poskytuje podobnou funkcionalitu v~podobě kotev a~aliasů. V~libovolné části souboru je možné definovat tzv. kotvu, na kterou je pak možné se odkázat ve zbývající části souboru pomocí aliasu. Kotva začíná znakem \texttt{\&} (ampersand) a~za ním následuje její název, který si uživatel může zvolit. Alias začíná znakem \texttt{*} (hvězdička) a~za ní je bezprostředně uveden název již existující kotvy. Definice kotvy a~použití aliasu může vypadat například následovně.

\vspace{5pt}
\begin{lstlisting}
primary_equation: !Unsteady_LMH
  time: &time
    end_time: 0.5
    max_dt: 0.01
    min_dt: 0.01
time: *time
\end{lstlisting}
\vspace{-20pt}

Použití kotev a~aliasů bylo navrženo ve formátu \gls{YAML} za stejným účelem jako reference ve formátu \gls{CON} -- ke zrychlení zápisu duplicitních dat. Formát \gls{YAML} byl ovšem navržen tak, aby byl schopný zpracovávat i~proud dat, nikoli pouze kompletní soubory. To vedlo k~tomu, že kotvy je nutné vždy definovat dříve, než je možné je použít jako alias.

Tím se použití kotev a~aliasů liší od referencí ve formátu \gls{CON}. V~něm bylo možné se odkázat i~na datovou strukturu, která v~dané fázi zpracování souboru ještě nebyla definovaná. Nicméně vzhledem k~účelu referencí -- předejití duplicitě dat -- není tato funkcionalita zásadní. 


\section{Datová struktura}

\subsection{Získání datové struktury}

V~rámci aplikace je zapotřebí s~daty, která jsou zapsaná v~konfiguračním souboru, dále pracovat. Z~konfiguračního souboru je tedy potřeba získat vhodnou datovou strukturu, která bude podporovat operace, které potom využijí jiné části aplikace. Proces získání datové struktury z~konfiguračního souboru je znázorněn na obrázku~\ref{img:data_structure_chain}.

\includeimg{data_structure_chain}{Získání datové struktury z~konfiguračního souboru}

Na začátku řetězce je vstupní konfigurační soubor. Z~toho se získá obsah pomocí lexikální a~syntaktické analýzy jazyka \gls{YAML}. Tato data se dále zpracovávají speciální vrstvou, která provede potřebné autokonverze. Výstupem z~celého tohoto procesu je výsledná datová struktura, se kterou se v~aplikaci dále pracuje.

\subsection{Návrh datové struktury}

Datová struktura z~pohledu konfiguračních souborů, resp. Flow123d, byla popsána v~kapitole~\ref{sec:datova-struktura}. Jak bylo řečeno, datová struktura tvoří strom. Jednotlivé uzly tedy mohou být buď interní, což znamená, že obsahují další potomky, nebo mohou být koncové a~jsou to tedy tzv. listy. Na obrázku~\ref{img:data_node} je znázorněna navržená datová struktura pomocí diagramu \gls{UML}. Více o~modelovacím jazyku \gls{UML} je možné se dočíst v~příslušné normě~\cite{bib:uml}.

\begin{figure}[h]
	\centering
    \includegraphics[width=0.7\textwidth]{../img/data_node.pdf}
    \caption{UML diagram datové struktury}
	\label{img:data_node}
\end{figure}

Obecná abstrakce datového uzlu je reprezentována třídou \textit{DataNode}. Od této třídy jsou odvozeny implementace \textit{ScalarDataNode} a~\textit{CompositeDataNode}. Třída \textit{ScalarDataNode} reprezentuje list stromu a~tím pádem obsahuje nějakou skalární hodnotu. Třída \textit{CompositeDataNode} reprezentuje interní uzel stromu, který obsahuje další uzly \textit{DataNode}. Abstraktní třída \textit{CompositeDataNode} má dvě odvozené třídy -- \textit{MappingDataNode} pro záznamy a~\textit{SequenceDataNode} pro pole. Popsaná a~znázorněná reprezentace datové struktury odpovídá návrhovému vzoru \textit{Composite}. Více o~tomto a~dalších návrhových vzorech se lze dočíst v~knize Design Patterns~\cite{bib:design-patterns}.

V~aplikaci se pracuje s~abstrakní třídou \textit{DataNode}, která reprezentuje obecný uzel a~poskytuje všechny potřebné informace o~datové struktuře. Typicky se v~rámci aplikace pracuje s~kořenovým uzlem stromu, ze kterého je možné se dostat do všech ostatních uzlů.

\section{Autokonverze}
\label{sec:navrh-autokonverze}

V~konfiguračních souborech se často používají zkrácené zápisy, které je potřeba zpracovat pomocí autokonverzí, které byly podrobně popsány v~kapitole~\ref{sec:analyza-autokonverze}. Proces autokonverzí, obdobně jako třeba validace, potřebuje ke své funkci ne pouze konfigurační soubor, ale i~specifikaci formátu, která předepisuje očekávané datové typy.

Pro zpracování autokonverzí byl v~rámci aplikace navržen samostatný modul, který zkonvertuje vstupní datovou strukturu spolu se specifikací formátu dle dříve zmíněných pravidel pro autokonverze. Autokonverze pracuje vždy s~nějakým uzlem v~datové struktuře a~funguje rekurzivně. Pokud se tedy proces autokonverze spustí na kořen stromu, dojde ke všem potřebným autokonverzím. Kompletní logika procesu autokonverzí je znázorněna na obrázcích~\ref{img:autoconversion_process},~\ref{img:autoconversion_process_2}  a~\ref{img:autoconversion_process_3} pomocí vývojových diagramů. 

\begin{figure}[h]
	\centering
    \includegraphics[width=0.95\textwidth]{../img/autoconversion_process.pdf}
    \caption[Proces autokonverze I.]{Proces autokonverze I. -- Počáteční stav, kdy se ověřuje shoda datových typů, a~případné provedení autokonverze na záznam}
	\label{img:autoconversion_process}
\end{figure}

Začátek celého procesu se nachází na obrázku~\ref{img:autoconversion_process}.  Nejprve se zkontroluje, zda datový typ uzlu odpovídá očekávanému datovému typu. Pokud je datový typ správný, tak se pro danou datovou strukturu žádná autokonverze neprovede, ale rekurzivně se stejný proces opakuje i~pro všechny přímé potomky této datové struktury.

K~autokonverzi může dojít v~případě, že se datový typ daného uzlu neshoduje s~datovým typem, který se na tomto místě v~datové struktuře očekává. Pokud tato situace nastane, tak se nejprve ověří, zda se očekává záznam. Pokud tomu tak je a~zároveň tento záznam podporuje funkci autokonverze, tak dojde k~autokonverzi na záznam, jak bylo popsáno v~kapitole~\ref{sec:analyza-autokonverze-zaznam}.

\clearpage

Další fáze pokračuje na obrázku~\ref{img:autoconversion_process_2}. Zde se rozhoduje, zda je očekávaným datovým typem pole. Pokud tomu tak je, tak záleží, jakého datového typu je aktuální uzel. Pokud se jedná o~skalární hodnotu, tak proběhne autokonverze na pole, která je schopná provést konverzi i~na vícerozměrné pole. Funkce autokonverze na pole byla popsána v~kapitole~\ref{sec:analyza-autokonverze-pole}.

\begin{figure}[h]
	\centering
    \includegraphics[width=0.8\textwidth]{../img/autoconversion_process_2.pdf}
    \caption[Proces autokonverze II.]{Proces autokonverze II. -- Rozhodovací logika, která určuje, zda se má provést autokonverze na pole}
	\label{img:autoconversion_process_2}
\end{figure}

Pokud se očekává pole a~místo toho je uzel typu záznam, tak situace je komplikovanější, protože je potřeba určit, zda stačí provést autokonverzi na pole, nebo zda-li se jedná o~transpozici. Tento proces popisuje poslední obrázek znázorňující proces autokonverzí, obrázek~\ref{img:autoconversion_process_3}.

Detekce transpozice spočívá v~následujících krocích. Za prvé se již počítá s~faktem, že v~této fázi se musí provést buď transpozice nebo autokonverze na pole (pokud nedojde k~chybě transpozice díky špatným vstupním datům). Na základě toho lze odvodit datový typ očekávaného záznamu, který se má po autokonverzi získat, a~tím pádem i~očekávaný datový typ jeho potomků.

U~aktuálního uzlu se postupně projdou všichni přímí potomci a~dojde ke kontrole jejich datového typu oproti očekávanému datovému typu. Pokud se jedná o~pole, které se zde ovšem neočekává, signalizuje to použití transpozice. V~tuto chvíli se délka tohoto pole uloží a~zkontroluje. Aby transpozice mohla proběhnout, musí souhlasit délka všech neočekávaných polí -- pokud nesouhlasí, jedná se o~chybně zadaný vstup. Po zkontrolování všech přímých potomků se dorazí do větve, která rozhoduje, zda se má provést transpozice nebo autokonverze na pole. Pokud byla během procesu kontroly potomků definována délka pole a~nedošlo k~chybě, tak se provede transpozice tak, jak byla popsána v~kapitole~\ref{sec:analyza-autokonverze-transpozice}. Pokud se v~záznamu nevyskytla žádná neočekávaná pole, tak se provede autokonverze na pole.

\begin{figure}[H]
	\centering
    \includegraphics[width=\textwidth]{../img/autoconversion_process_3.pdf}
    \caption[Proces autokonverze III.]{Proces autokonverze III. -- Rozhodovací logika, která určuje, zda lze provést transpozice}
	\label{img:autoconversion_process_3}
\end{figure}

\clearpage

\section{Validace}

Jednou z~nejužitečnějších funkcí editoru je validace, která umožňuje odhalit chyby a~možné problémy se zadanou konfigurací již během vytváření konfiguračních souborů. Vstupem do validace je datová struktura, která vznikla z~dat konfiguračního souboru po provedení výše popsaných autokonverzí. Během procesu validace se tato datová struktura rekurzivně prochází a~zaznamenávají se detekované chyby. Po dokončení procesu validace je uživatel upozorněn na tyto chyby pomocí grafického uživatelského rozhraní aplikace.

Validace ke své funkci potřebuje specifikaci formátu, na základě které ověřuje, zda mají vstupní data předepsanou strukturu a~splňují všechna omezení. Jelikož validace pracuje s~dynamicky zadanou specifikací formátu, tak je možné validaci provést pro libovolnou verzi Flow123d, kterou si uživatel může zvolit v~uživatelském rozhraní.

\begin{figure}[h]
	\centering
    \includegraphics[width=0.65\textwidth]{../img/validation_type.pdf}
    \caption{Validace datového typu}
	\label{img:validation_type}
\end{figure}

Prvním krokem validace je detekce a~ověření zadaného datového typu. Tento proces je znázorněn na obrázku~\ref{img:validation_type}. Pokud neodpovídá zadaný datový typ očekávanému, aplikace se pokusí převést datový typ na očekávaný, pokud je to možné. Poté se provede validace, která závisí na datovém typu (tyto validace jsou postupně popsány dále). Pokud datový typ nelze převést na očekávaný, dojde k~chybě \textit{ValidationTypeError}. 

\subsection{Validace primitivních datových typů}

Některé z~primitivních datových typů nemají žádnou typově specifickou validaci. Aktuálně se jedná o~řetězce, názvy souborů a~booleovské hodnoty (\textit{String}, \textit{Filename} a~\textit{Boolean}). U~těchto datových typů se provede pouze kontrola datového typu a~případná konverze, jak bylo popsáno výše.

\begin{figure}[h]
	\centering
    \includegraphics[width=0.68\textwidth]{../img/validation_number.pdf}
    \caption{Validace číselných datových typů -- \textit{Integer} a~\textit{Double}}
	\label{img:validation_number}
\end{figure}

Číselné datové typy pro reprezentaci celých a~desetinných čísel (\textit{Integer} a~\textit{Double}) mohou mít ve specifikaci formátu zadaný interval platných hodnot, který je shora i~zdola uzavřený. Provádí se tedy kontrola, zda se zadané číslo nachází v~tomto intervalu. Pokud je hodnota menší než požadované minimum, dojde k~chybě \textit{Value\-Too\-Small}. V~opačném případě, kdy je hodnota větší než požadované maximum, dojdě k~chybě \textit{ValueTooBig}. Validaci číselných datových typů znázorňuje obrázek~\ref{img:validation_number}.


\begin{figure}[h]
	\centering
    \includegraphics[width=0.6\textwidth]{../img/validation_selection.pdf}
    \caption{Validace výčtového datového typu -- \textit{Selection}}
	\label{img:validation_selection}
\end{figure}

Posledním primitivním datovým typem, který má speciální validaci, je výčtový datový typ (\textit{Selection}). U~tohoto datového typu se ověří, zda je zadaná hodnota jednou z~možných hodnot, která je uvedena ve specifikaci formátu. Pokud zadaná hodnota není uvedena ve specifikaci formátu, dojde k~chybě \textit{InvalidSelectionOption}. Validaci výčtového datového typu znáznorňuje obrázek~\ref{img:validation_selection}.

\clearpage
\subsection{Validace pole}

\begin{figure}[h]
	\centering
    \includegraphics[width=0.75\textwidth]{../img/validation_array.pdf}
    \caption{Validace pole -- \textit{Array}}
	\label{img:validation_array}
\end{figure}

U~polí může být omezen počet prvků, které mohou obsahovat. Toto omezení je zadáno pomocí intervalu, který je z~obou stran uzavřený. Proces validace tedy probíhá obdobně jako při validaci číselných datových typů s~tím rozdílem, že se kontroluje počet prvků pole. Případná chybová hlášení se také liší. Pokud je počet prvků v~poli menší než zadané minimum, dojde k~chybě \textit{NotEnoughItems}. V~opačném případě dojde k~chybě \textit{TooManyItems}. Po kontrole počtu prvků pole se postupně prochází jeho potomci, u~kterých se opět provádí validace. Validace pole je znázorněna na obrázku~\ref{img:validation_array}.

\clearpage
\subsection{Validace záznamu}

\begin{figure}[h]
	\centering
    \includegraphics[width=0.91\textwidth]{../img/validation_record.pdf}
    \caption{Validace záznamu -- \textit{Record}}
	\label{img:validation_record}
\end{figure}

Záznamy jsou opět složeným typem, takže součástí procesu je opět validace potomků. Průběh validace záznamu je znázorněn na obrázku~\ref{img:validation_record}. Během tohoto procesu se postupně ověřují všechny klíče záznamu, které obsahují jeho potomky. Pro každý z~těchto klíčů se najde jeho odpovídající datový typ ve specifikaci formátu. Pokud v~ní není daný klíč uveden, dojde k~upozornění \textit{UnknownRecordKey} a~pokračuje se dalším klíčem. Po validaci všech klíčů, resp. potomků, se ještě ověří, ze jsou v~záznamu uvedeny všechny povinné klíče. Pokud tomu tak není, je uživatel na chybějící klíče upozorněn pomocí chyby \textit{MissingObligatoryKey}.

Validace umožňuje různé úrovně chybových hlášení -- informativní zprávy, upozornění, chyby a~fatální chyby. Ve výše popsané validaci může kromě chyb vzniknout i~upozornění \textit{UnknownRecordKey}. K~tomu dojde tehdy, když se v~záznamu vyskytne klíč, který není uveden ve specifikaci formátu. Z~hlediska Flow123d se nejedná o~chybu. V~praxi se však v~těchto případech často jedná o~překlep nebo špatný název nepovinného klíče, na který potom Flow123d nijak nereaguje. Uživatel pak musí pracně zjišťovat, proč se simulátor chová jinak, než očekává. Z~toho důvodu validace upozorňuje i~na tyto případy.

\subsection{Validace abstraktního záznamu}

Posledním datovým typem, který se může na vstupu očekávat, je abstraktní záznam (\textit{Abstract}). Proces validace abstraktního záznamu je znázorněn na obrázku~\ref{img:validation_abstract}. Nejprve se určí, zda je explicitně zadán typ abstraktního záznamu (viz kapitola~\ref{sec:navrh-yaml-abstrakni-zaznamy}). Pokud je uveden, tak se ověří, ze tento záznam je implementací očekávaného abstraktního záznamu. Pokud by nebyl, validace skončí chybou \textit{InvalidAbstractType}.

Jestliže není explicitně uvedený typ, tak se použije výchozí datový typ implementace, pokud je uveden ve specifikaci formátu. Pokud ovšem abstraktní záznam nemá výchozí implementaci, validace skončí chybou \textit{UnknownRecordKey}. Ve chvíli, kdy je určen konkrétní datový typ záznamu, se může provést jeho validace tak, jak byla výše popsaná.

\begin{figure}[H]
	\centering
    \includegraphics[width=0.98\textwidth]{../img/validation_abstract.pdf}
    \caption{Validace abstraktního záznamu -- \textit{Abstract}}
	\label{img:validation_abstract}
\end{figure}

\section{Vizualizace datové struktury}

Jednou z~komponent editoru je grafický strom, který slouží pro vizualizaci datové struktury. V~prvotní fázi plánování editoru se uvažovalo o~tom, že by se pomocí tohoto grafického stromu kompletně zadávala celá konfigurace a~editor by neměl žádnou komponentu pro přímou úpravu zdrojového textu konfiguračního souboru. Nakonec se ovšem od tohoto návrhu upustilo z~několika důvodů. Jednou z~nevýhod je například to, že takový editor by uživateli neposkytoval žádnou kontrolu nad formátováním textu v~konfiguračních souborech. S~tím souvisí i~problém komentářů, které by nebylo možné do konfiguračního souboru jednoduše zapsat na požadované místo. Dalším z~důvodů bylo i~to, že jsou modeláři zvyklí editovat konfigurační soubor ve formě textu.

Komponenta stromu má ovšem oproti pouhému editoru textu i~určité výhody a~proto byla v~aplikaci nakonec použita. Zatímco zápis a~všechny úpravy datové struktury se provádí editací textu, komponenta stromu slouží primárně jako vizualizace zadaných dat. Strom slouží k~rychlé orientaci v~konfiguračním souboru, označování hodnot a~poskytuje náhled, jak vypadá datová struktura po provedení autokonverzí.

Komponenta stromu je rozdělena do dvou sloupců. V~levém se nachází klíče nebo indexy pole a~v~pravém sloupci jsou příslušné hodnoty. Stromová struktura je znázorněna pomocí odsazení v~levém sloupci. Jednotlivé větve stromu je možné zabalit pro přehlednější výpis požadovaných informací. Komponentu stromu je možné vidět na obrázku~\ref{img:gui_tree} na straně~\pageref{img:gui_tree}.

Po kliknutí na libovolnou hodnotu či klíč dojde k~jejímu označení v~textu konfiguračního souboru. To má v~zásadě dvě využití. Pokud je konfigurační soubor delší, než se vejde do okna editoru, tak se pozice okna textového editoru upraví tak, aby byla hodnota viditelná, takže uživatel se může rychle zorientovat. Díky tomu, že se zároveň označí, tak je možné ji rychle a~pohodlně přepsat.

Komponenta stromu aktuálně podporuje zvýraznění typů abstraktních záznamů. V~rámci budoucích rozšíření aplikace by mohla podporovat i~další zvýraznění někte\-rých hodnot či datových typů. Kromě toho by bylo pohodlné, kdyby strom dokázal lépe zobrazovat dvourozměrná pole hodnot, například pomocí matice. To je ovšem otázkou budoucích vylepšení aplikace \textit{ModelEditor}, nikoli předmětem této diplomové práce.

\clearpage

\section{Textový editor}

Hlavní komponentou aplikace \textit{ModelEditor} je textový editor, který umožňuje upravovat text konfiguračního souboru. Editor byl optimalizován pro vytváření a~upravování konfiguračních souborů Flow123d ve formátu \gls{YAML}.

Rozhraní editoru zobrazuje čísla řádků, poskytuje základní zvýraznění syntaxe a~zobrazuje vodící čáry pro lepší orientaci v~úrovni odsazení. Přímo v~okně textového editoru je na příslušných řádcích uživatel upozorněn na případné chyby pomocí ikony, která odpovídá závažnosti chyby. Po kliknutí na tuto ikonu se uživateli zobrazí podrobný popis chyby a~označí se její lokace v~textu. Ukázku grafického rozhraní komponenty textového editoru a~seznamu notifikací je možné najít na obrázku~\ref{img:gui_editor_notifications}, resp.~\ref{img:gui_notifications} na straně~\pageref{img:gui_editor_notifications}. 

Editor také podporuje funkci automatického doplňování textu, které značně urychluje zápis konfiguračních souborů. Na obrázku~\ref{img:gui_editor_autocompletion} na straně~\pageref{img:gui_editor_autocompletion} je znázorněn textový editor s~vyvolanou nabídkou pro automatické doplňování textu. Pomocí funkce automatického doplňování je možné vybrat hodnotu z~nabízeného seznamu místo jejího celého zápisu. Tato funkce pracuje na základě specifikace formátu a~je citlivá na pozici v~datové struktuře. To znamená, že nabízí k~doplnění pouze ty hodnoty, které mají na současné pozici smysl. Například při doplňování názvu klíče jsou nabízené možnosti závislé na tom, ve kterém záznamu je aktuálně umístěn kurzor. Funkce automatického doplňování umožňuje v~konfiguračních souborech doplňovat:

\begin{itemize}
\item názvy klíčů v~záznamech,
\item datové typy záznamů,
\item hodnoty výčtových typů,
\item uživatelsky definované kotvy\footnote{Uživatelsky definované kotvy slouží jako reference, viz kapitola~\ref{sec:navrh-yaml-reference}.}.
\end{itemize}

Textový editor podporuje i~běžné operace pro manipulaci s~textem, které se od textového editoru očekávají. Editor podporuje následující operace:

\begin{itemize}
\item operace vracení změn (mechanismus undo/redo);
\item práce se schránkou -- vložení, vyjmutí, kopírování;
\item nalezení a~nahrazení\footnote{Funkce nalezení a~nahrazení podporuje i~regulární výrazy.};
\item změna odsazení bloku;
\item zakomentování nebo odkomentování označeného bloku.
\end{itemize}


\section{Kontextová nápověda}

Poslední z~hlavních komponent editoru je kontextová nápověda. Tato komponenta slouží pro zobrazení dokumentace k~aktuálně upravované části datové struktury. Obsah této nápovědy je totožný s~kompletním referenčním manuálem, který má několik desítek stran. Hlavním rozdílem je ovšem to, že komponenta kontextové nápovědy zobrazuje uživateli pouze informace, které bezprostředně souvisí s~právě editovanou částí konfiguračního souboru. Kontextová nápověda tedy poskytuje mnohem pohodlnější a~příjemnější rozhraní k~již existující dokumentaci.

Všechny informace potřebné pro generování dokumentace se opět nachází ve specifikaci formátu. Tím pádem i~funkce kontextové dokumentace je schopná se přizpůsobit vybrané verzi Flow123d.

Kontextová dokumentace zároveň pracuje s~pozicí kurzoru v~okně editoru, na základě které se určuje aktuální pozice v~datové struktuře, podle které se zobrazí příslušná část dokumentace.

Struktura konfiguračních souborů je taková, že všechna data\footnote{Kromě samotného kořenového uzlu celé datové struktury.} mají nějaký nad\-řa\-ze\-ný záznam a~jsou zapsána v~nějakém klíči. Z~toho vychází, jaké informace se zobrazují v~kontextové nápovědě. V~té jsou zobrazeny následující informace:

\begin{itemize}
\item název a~popis nadřazeného záznamu,
\item seznam všech možných klíčů tohoto záznamu,
\item popis aktuálně vybraného klíče,
\item datový typ klíče a~jeho popis.
\end{itemize}

Pokud je nadřazený záznam implementací některého abstraktního záznamu, zobrazí se navíc ještě název a~popis tohoto abstraktního záznamu včetně seznamu jeho možných implementací, které se skládají z~názvu a~popisu.

Všechny názvy složených datových typů a~klíčů záznamů jsou odkazy, na které je možné kliknout. Dokumentaci zobrazenou v~kontextové nápovědě je tak možné procházet. Dále je možné pro navigaci použít tlačítka zpět, vpřed a~domů, podobně jako v~internetových prohlížečích.

Vzhled komponenty v~grafickém rozhraní aplikace a~ukázky zobrazovaných dat je možné vidět na obrázcích~\ref{img:gui_doc_mortar_method},~\ref{img:gui_doc_substances} a~\ref{img:gui_doc_format} na straně~\pageref{img:gui_doc_mortar_method}.


\chapter{Implementace a~testování}

Aplikace \textit{ModelEditor} je součástí aplikačního balíku \textit{GeoMop}, za jehož vývoj je zodpovědný Ing. Pavel Richter. V~rámci této diplomové práce byly v~aplikaci \textit{Model\-Editor} implementovány následující funkce:

\begin{itemize}
\item datová struktura pro práci s~konfiguračními soubory a~specifikací formátu,
\item zpracování konfiguračního souboru ve formátu \gls{YAML},
\item proces autokonverzí,
\item proces validace,
\item generování kontextové dokumentace,
\item automatické doplňování textu,
\item grafické rozhraní aplikace včetně jeho komponent.
\end{itemize}

Kromě těchto funkcí ovšem \textit{ModelEditor} obsahuje i~části, na kterých pracoval Ing.~Richter a~nevznikly tedy v~rámci této diplomové práce. Konkrétně se jedná o~následující funkce:

\begin{itemize}
\item rozhodovací logika, která určuje, kdy má dojít k~opětovnému načtení datové struktury,
\item import formátu \gls{CON},
\item transformace.
\end{itemize}

Nejužší souvislost s~touto diplomovou prací má rozhodovací logika pro opětovné načtení datové struktury. Výše popsaný proces zpracování formátu \gls{YAML}, autokonverzí, validací, generování dokumentace a~reprezentace dat musí probíhat neustále dokola. Když uživatel upravuje text souboru, mění se data i~pozice kurzoru. Na těchto informacích závisí všechny zmíněné funkce. Pokud by ovšem celý proces měl probíhat při každém napsaném znaku, vedlo by to ke zbytečnému vytížení procesoru a~znatelnému zpomalení aplikace. Bylo tedy nutné implementovat funkcionalitu, která rozhodne, kdy má dojít k~opětovnému načtení datové struktury a~aktualizaci všech komponent, které na ní závisí.

Dále \textit{ModelEditor} obsahuje doplňkové funkce jako import formátu CON, ve kterém se dříve psaly konfigurační soubory, nebo transformace, které umožňují upravovat datovou strukturu (a~tedy i~text konfiguračního souboru) pomocí předdefi\-no\-va\-né sady pravidel. Transformace je možné využít například pro konverzi konfiguračních souborů mezi různými verzemi Flow123d, kde došlo ke změně specifikace formátu.


\section{Požadavky}

Na aplikaci \textit{ModelEditor} se vztahují určité požadavky, které vychází z~požadavků na celý aplikační balík \textit{GeoMop}. Jedná se především o~následující požadavky:

\begin{itemize}
\item Aplikace je vyvíjena jako open-source pod licencí \acrshort{GNU} \gls{GPL} v3.0~\cite{bib:gnu-gpl3}.
\item Aplikace musí být multiplatformní a~má podporovat systémy Windows (XP a~novější) a~Linux.
\item Aplikace je napsaná v~jazyce Python~3~\cite{bib:python3}.
\item Aplikace používá knihovnu PyQt~5~\cite{bib:pyqt5} pro grafické rozhraní.
\item Pro vývoj aplikace se používá verzovací systém Git. Aktuální verze zdrojových kódů je veřejně dostupná na adrese: \url{https://github.com/GeoMop/GeoMop}.
\item Pro dokumentaci zdrojových kódů se používá nástroj Sphinx~\cite{bib:sphinx}.
\end{itemize}


\section{Zpracování formátu YAML}
\label{sec:implementace-yaml}

V~kapitole~\ref{sec:analyza-proces-zpracovani-yaml} byl popsán proces zpracování formátu \gls{YAML}, který je rozdělen do čtyř vrstev -- prezentace, serializace, reprezentace a~datová struktura. Uvedený postup zpracování, který je původně definován v~dokumentaci \gls{YAML}~\cite{bib:yaml}, se většinou dodržuje i~v~konkrétních implementacích knihoven, které se používají pro zpracování \gls{YAML}. V~jazyce Python je dostupná knihovna \textit{PyYAML}~\cite{bib:pyyaml}, která až na některé detaily odpovídá dokumentaci.

Rozhraní nejvyšší úrovně poskytuje funkci, jejímž vstupem je text obsahující data ve formátu \gls{YAML} a~výstupem jsou nativní datové struktury v~jazyce Python -- slovníky, seznamy a~hodnoty. Vrstva datové struktury je tedy kompletně oddělená od její prezentace\footnote{Prezentací se rozumí zápis formátu \gls{YAML} v~podobě textového souboru.}, což je v~souladu s~dokumentací \gls{YAML}.

Pro potřeby aplikace \textit{ModelEditor} je toto chování nevyhovující. V~aplikaci je zásadní pozice symbolů v~textu, aby bylo možné s~textovým editorem interaktivně pracovat. Tato informace je dostupná pouze nižším vrstvám v~rámci zpracování souboru. Dále je potřeba v~rámci aplikace rozeznávat reference -- což také není možné, protože data jsou ve výsledné struktuře pouze zkopírovaná a~nelze tím pádem určit, která data byla zdrojová. Posledním úskalím pak byl zápis typu abstraktních záznamů pomocí tagů. Knihovna \textit{PyYAML} se pokouší interpretovat tagy jako názvy tříd v~Pythonu, což je pro účely aplikace \textit{ModelEditor} opět nežádoucí.

Z~knihovny \textit{PyYAML} byla tedy využita pouze nejnižší úroveň zpracování, která provede pouze lexikální analýzu. Výstupem z~tohoto procesu je seznam událostí. Tento seznam událostí je dále zpracováván aplikací \textit{ModelEditor}, který na jejím základě vytváří aplikačně specifickou datovou strukturu, která obsahuje všechny potřebné informace. Výsledkem je tedy modul, který vychází z~knihovny \textit{PyYAML} a~na nejvyšší úrovni poskytuje funkci, která umožňuje načíst vstupní text ve formátu \gls{YAML} a~výstupem z~této funkce je datová struktura aplikace.


\section{Textový editor}

Pro komponentu textového editoru byla použita knihovna \textit{QScintilla~2}~\cite{bib:qscintilla2-python} pro Python, což je port knihovny \textit{Scintilla}~\cite{bib:scintilla} do grafického prostředí \textit{Qt}. \textit{Scintilla} poskytuje multiplatformní komponentu, která podporuje mnoho funkcí, které se používají při editaci zdrojového kódu. Podporuje například zobrazení čísel řádků, zobrazení indikátorů chyb, zvýraznění syntaxe, doplňování textu a~další.

\textit{QScintilla} se snaží většinu funkcí z~knihovny \textit{Scintilla} obalit a~poskytnout k~nim vlastní \gls{API}, které by mělo zjednodušit jejich použití. Při implementaci se ovšem ukázalo, že pro některé funkce je nutné použít nízkoúrovňový přístup, při kterém se volaly přímo funkce editoru \textit{Scintilla} pomocí zasílání zpráv, které není příliš dobře zdokumentované. Pomocí tohoto přístupu bylo potřeba zajistit funkci automatického doplňování a~použití správných znaků pro ukončení řádky podle platformy.

Automatické doplňování je poskytováno i~pomocí funkcí z~\textit{QScintilla}~\gls{API}. Ovšem poskytovaná funkčnost je značně omezená a~neumožňovala by tak například vhodně filtrovat nabízené možnosti podle kontextu. Oproti tomu přímý přístup k~rozhraní \textit{Scintilla} poskytuje plnou kontrolu nad komponentou automatického doplňováním i~nad samotným textem editoru. Díky tomu bylo možné tuto funkcionalitu realizovat tak, aby splňovala všechny požadavky.

Další implementační zajímavostí byl mechanismus vracení provedených změn. \gls{API} poskytuje funkce, které toto umožňují implementovat. Ovšem v~jejich nezmě\-ně\-né podobě probíhá vracení operací po nejmenší možné jednotce -- tedy po napsaných znacích. Z~uživatelského hlediska není takové chování žádoucí, protože zachycené změny jsou příliš drobné a~často nepodstatné. Tento mechanismus byl proto rozšířen tak, aby podporoval vrácení změn po větších částech -- konkrétně po částech, které vyvolají opětovné načtení datové struktury. Typicky se jedná o~třeba dokončení řádky nebo vložení textu ze schránky.

\section{Kontextová nápověda}

Při tvorbě komponenty pro zobrazování kontextové nápovědy bylo vzato v~úvahu následující:

\begin{itemize}
\item grafický vzhled nemusí být finální a~měl by jít upravovat,
\item položky nápovědy by mezi sebou měly být propojené pomocí odkazů,
\item v~rámci dokumentačních řetězců se mohou vyskytnout rovnice zapsané pomocí syntaxe \texttt{math} prostředí \TeX,
\item v~současnosti existuje knihovna, která generuje ze specifikace formátu dokumentaci ve formátu \gls{HTML}.
\end{itemize}

Vzhledem k~těmto skutečnostem byla kontextová nápověda realizována pro\-střed\-nictvím komponenty \textit{QWebView}, která funguje jako primitivní internetový prohlížeč s~omezenou podporou \gls{HTML}, \gls{CSS} a~\gls{JS}. Ze specifikace formátu, která obsahuje dokumentační řetězce a~další informace o~datové struktuře, se generuje webová stránka, která se poté pomocí této komponenty zobrazí.

Pro generování HTML byla využita stávající knihovna \textit{Flow123d-python-utils\footnote{\url{https://github.com/x3mSpeedy/Flow123d-python-utils}}}, jejíž autorem je Ing.~Jan Hybš. Z~této knihovny byla použita odpovídající část, která slouží pro generování dokumentace, a~ta byla dále upravena pro potřeby aplikace \textit{ModelEditor}. Knihovna řeší i~vykreslení rovnic pomocí nástroje KaTeX\footnote{\url{https://github.com/Khan/KaTeX}}.

Během implementace bylo nutné nahradit či obejít některé vlastnosti \gls{HTML}, \gls{CSS} a~\gls{JS}, protože jejich podpora v~komponentě \textit{QWebView} je v~porovnání s~moderními webovými prohlížeči značně omezená. Použití této komponenty bylo ovšem výhodné v~tom, že je přímo součástí \textit{Qt} a~nebyla tak zapotřebí žádná další externí knihovna, která by poskytovala komponentu okna webového prohlížeče.

\section{Testování}

V~rámci vývoje byly psány testy pro ověření funkčnosti aplikace. Snahou ovšem nebylo dosáhnout 100\% pokrytí kódu testy. Potřebná časová investice by byla naprosto neúměrná reálnému přínosu. Spíše byl kladen důraz na psaní testů pro moduly, které se často měnily a~upravovaly, nebo se očekává, že by v~se v~budoucnu mohly měnit. Dále byly vytvořeny testy pro ty části aplikace, které jsou jednoznačné a~snadno testovatelné a~dalo by se říct, že jejich funkcionalita je pomocí testů nadefinovaná. U~těchto částí aplikace byl v~rámci vývoje použit přístup \gls{TDD}.

Bylo napsáno celkem 206 testů. Většinou se jedná o~jednotkové testy, které testují nějakou konkrétní funkci, metodu, třídu či komponentu. Jsou mezi nimi ovšem i~testy, které by se daly považovat za integrační testy, protože testují více komponent najednou a~interakce mezi nimi. Z~těchto 206 testů bylo napsáno:

\begin{itemize}
\item 72 testů pro datovou strukturu a~operace, které s~ní souvisí -- načtení souboru \gls{YAML}, autokonverze a~validace;
\item 115 testů pro pomocné třídy, které zajišťují především analýzu textu;
\item 5 testů pro uživatelské rozhraní;
\item 14 testů pro serializaci a~ukládání nastavení aplikace.
\end{itemize}

Kromě jednotkových a~integračních testů bylo součástí testování i~manuální ověření funkčnosti aplikace a~její odladění. Manuálně bylo testováno především uživatelské rozhraní a~interakce mezi komponentami. Většina chyb, které byly odhaleny během testování, byla odstraněna. Některé chyby, které nebyly zásadní a~jednalo se spíše o~nedostatky, byly pouze zaznamenány. Jejich odstranění je záležitostí dalšího vývoje aplikace \textit{ModelEditor} v~rámci projektu \textit{GeoMop}. Aplikace byla testována i~několika cílovými uživateli a~jejich připomínky a~náměty vedly k~některým změnám a~vylepšením.


\chapter*{Závěr}
\addcontentsline{toc}{chapter}{Závěr}
V~rámci této diplomové práce vznikl editor konfiguračních souborů pro Flow123d. Jedná se o~samostatně použitelnou aplikaci, která je ovšem navržena s~ohledem na její integraci do softwarového balíku GeoMop, který obsahuje další nástroje, které usnadňují práci uživatelům Flow123d.

Editor uživatelům zjednodušuje vytváření a~upravování konfiguračních souborů. Umožňuje ověřit správnost zadané konfigurace pro zvolenou verzi Flow123d a~upozorňuje uživatele na detekované chyby. Tato funkce přináší uživateli časovou úsporu a~uživatelsky příjemnější rozhraní pro odhalení a odstranění chyb.

Editor dále uživatelům poskytuje kontextovou nápovědu, která zobrazuje dokumentaci, které bezprostředně souvisí s částí konfiguračního souboru, kterou právě upravuje. Obsah nápovědy se interaktivně mění v závislosti na tom, jakou část konfiguračního souboru uživatel právě edituje, aby byla zobrazena vždy relevantní dokumentace. Pro uživatele to představuje značné zjednodušení, jelikož může využít tuto kontextovou nápovědu místo prohledávání rozsáhlé referenční dokumentace.

V~neposlední řadě editor obsahuje komponentu pro grafické znázornění datové struktury, která poskytuje alternativní pohled na zadaná data, a~umožňuje rychlejší orientaci v~rozsáhlých konfiguračních souborech. Kromě těchto stěžejních funkcí poskytuje editor uživateli i~běžné nástroje pro manipulaci s~textem, jako jsou například operace se schránkou, možnost vracení provedených změn, vyhledávání a~nahrazení nebo změna úrovně odsazení.

Aplikace je multiplatformní a~podporuje systémy Windows (XP nebo novější) a~Linux. Pro vývoj použit jazyk Python~3 a~grafická knihovna PyQt~5. K~aplikaci byly vytvořeny instalační balíčky pro Windows a~Debian.

V~rámci budoucího vývoje jsou plánovány další dodatečné funkce. Jedná se např. o~zlepšení zvýraznění syntaxe, které by mohlo zohledňovat datovou strukturu konfiguračních souborů Flow123d. Další možné vylepšení spočívá v~rozšíření funkcionality komponenty pro vizualizaci datové struktury, která by mohla v~budoucnu podporovat kromě i~editaci dat nebo vylepšené zobrazení speciálních datových typů.

\begin{thebibliography}{99}
% set url to non-mono style
\urlstyle{same}

\addcontentsline{toc}{chapter}{\bibname}

\bibitem{bib:ecma404}
\textsc{Ecma International.} \textit{Standard ECMA-404: The JSON Data Interchange Format.} [online]. Geneva: Ecma International, 2013. [cit. 2016-02-23] Dostupné na: $<$\url{http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf}$>$

\bibitem{bib:flow123d-manual}
\textsc{Březina, Jan et al.} \textit{Flow123d version 1.8.2: Documentation of file formats and brief user manual}. [online]. Liberec, 2015 [cit. 2016-02-24]. Dostupné na: $<$\url{http://flow.nti.tul.cz/packages/1.8.2_release/flow123d_1.8.2_doc.pdf}$>$

\bibitem{bib:sgml-iso}
\textsc{\acrshort{ISO}.} \textit{ISO 8879}. Amd.1:1988. \acrfull{ISO}, 1988. [cit. 2016-02-26]. 

\bibitem{bib:xml}
\textsc{\acrshort{W3C}.} \textit{Extensible Markup Language (XML) 1.0}. Fifth Edition. [online]. \acrfull{W3C}, 2008. [cit. 2016-02-26]. Dostupné na: $<$\url{http://www.w3.org/TR/2008/REC-xml-20081126}$>$

\bibitem{bib:yaml}
\textsc{Ben-Kiki, Oren et al.} \textit{YAML Ain’t Markup Language (YAML™) Version 1.2}. 3rd Edition. [online]. 2009. [cit. 2016-03-06]. Dostupné na: $<$\url{http://www.yaml.org/spec/1.2/spec.html}$>$

\bibitem{bib:uml}
\textsc{\acrshort{OMG}.} \textit{ISO/IEC 19505-1: Information technology - Object Management Group
Unified Modeling Language (OMG UML),
Infrastructure}. [online]. \acrfull{OMG}, 2012. [cit. 2016-03-21]. Dostupné na: $<$\url{http://www.omg.org/spec/UML/ISO/19505-1/PDF}$>$

\bibitem{bib:design-patterns}
\textsc{Gamma, Erich et al.} \textit{Design Patterns: Elements of Reusable Object-Oriented Software}. 1st Edition. Addison-Wesley Professional, 1994. ISBN 978-0201633610.

\bibitem{bib:gnu-gpl3}
\acrshort{FSF}. \textit{\acrshort{GNU} Project: The \acrshort{GNU} \acrlong{GPL} v3.0}. [online]. \acrfull{FSF}, 2007. [cit. 2016-03-26]. Dostupné na: $<$\url{http://www.gnu.org/copyleft/gpl.html}$>$

\bibitem{bib:python3}
\acrshort{PSF}. \textit{Python 3.4.4 Documentation}. [online]. \acrfull{PSF}, 2016. [cit. 2016-03-26]. Dostupné na: $<$\url{https://docs.python.org/3.4/}$>$

\bibitem{bib:pyqt5}
\textsc{\acrshort{RCL}.} \textit{PyQt~5 Reference Guide}. [online]. \acrfull{RCL}, 2016. [cit. 2016-03-26]. Dostupné na: $<$\url{http://pyqt.sourceforge.net/Docs/PyQt5/}$>$

\bibitem{bib:sphinx}
\textsc{Brandl, Georg et al.} \textit{Sphinx 1.3.7+ Documentation}. [online]. Georg Brandl and the Sphinx team, 2016. [cit. 2016-03-26]. Dostupné na: $<$\url{http://www.sphinx-doc.org/en/stable/}$>$

\bibitem{bib:pyyaml}
\textsc{Kirill, Simonov.} \textit{PyYAML}. [online]. 2014. [cit. 2016-04-12]. Dostupné na: $<$\url{http://pyyaml.org/wiki/PyYAML}$>$

\bibitem{bib:qscintilla2-python}
\textsc{\acrshort{RCL}}. \textit{QScintilla: QScintilla -- a~Port to Qt v4 and Qt v5 of Scintilla }. [online]. \acrfull{RCL}, 2016. [cit. 2016-04-11]. Dostupné na: $<$\url{http://pyqt.sourceforge.net/Docs/QScintilla2/}$>$

\bibitem{bib:scintilla}
\textsc{Scintilla}. \textit{Scintilla Documentation}. [online]. 2016. [cit. 2016-04-11]. Dostupné na: $<$\url{http://www.scintilla.org/ScintillaDoc.html}$>$



\end{thebibliography}

\clearpage
\appendix

\addcontentsline{toc}{chapter}{Přílohy}
\counterwithin{figure}{chapter}

\chapter{Ukázky kódů konfiguračních souborů}

\lstset{style=code}

\begin{figure}[h]
\begin{lstlisting}
{
  solver = {
    TYPE = "Petsc",
    a_tol = 1e-12,
    r_tol = 1e-12
  }
}
\end{lstlisting}
\vspace*{-20pt}
\caption{Výběr implementace abstraktního záznamu ve formátu CON}
\label{img:abstract-record-con}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}
solver: !petsc
  a_tol: 1e-12
  r_tol: 1e-12
\end{lstlisting}
\vspace*{-20pt}
\caption{Výběr implementace abstraktního záznamu ve formátu YAML}
\label{img:abstract-record-yaml}
\end{figure}

\clearpage

\begin{figure}[h]
\begin{lstlisting}
{
  primary_equation = {
    TYPE = "Unsteady_LMH",
    ...
    time = {
      end_time = 0.5, 
      max_dt = 0.01,
      min_dt = 0.01
    }
  },
  
  time = {
    REF = "../primary_equation/time"
  }
}
\end{lstlisting}
\vspace*{-20pt}
\caption{Použití reference ve formátu CON}
\label{img:reference-con}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}
primary_equation: !Unsteady_LMH
  ...
  time: &time
    end_time: 0.5
    max_dt: 0.01
    min_dt: 0.01

time: *time
\end{lstlisting}
\vspace*{-20pt}
\caption{Použití reference ve formátu YAML}
\label{img:reference-yaml}
\end{figure}

\clearpage
\begin{figure}[h]
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
{
  problem = {
    TYPE = "SequentialCoupling", 
    description = "Unsteady flow in 2D, Mixed Hybrid method", 
    mesh = {
      mesh_file = "${INPUT}/square_2d.msh"
    }, 
    primary_equation = {
      TYPE = "Steady_MH", 

      input_fields= [
        { region = "plane",
          conductivity = 1
        },
        { r_set = "BOUNDARY",
          time=0,
          bc_type = "dirichlet",
          bc_pressure = {TYPE="FieldFormula", value="0"}
        },
        { r_set = "BOUNDARY",
          time=1,
          bc_type = "dirichlet",
          bc_pressure = {TYPE="FieldFormula", value="x"}
        },
        { r_set = "BOUNDARY",
          time=2,
          bc_type = "dirichlet",
          bc_pressure = {TYPE="FieldFormula", value="2*x"}
        }
      ],

      n_schurs = 2, 
      output = {
        output_stream = {
          add_input_times=true,
          file = "./test09.pvd", 
          format = {
            TYPE = "vtk", 
            variant = "ascii"
          }, 
          name = "flow_output_stream"
        },
        output_fields = [ "pressure_p0", "pressure_p1", "velocity_p0" ]
      }, 

      balance = true,
      
      solver = {
        TYPE = "Petsc", 
        a_tol = 1e-07
      }
    } 
  } 
}
\end{lstlisting}
\vspace*{-20pt}
\caption{Konfigurační soubor \texttt{flow\_time\_dep} ve formátu CON}
\label{img:reference-con}
\end{figure}

\clearpage
\begin{figure}[h]
\begin{lstlisting}
problem: !SequentialCoupling
  description: Unsteady flow in 2D, Mixed Hybrid method
  mesh:
    mesh_file: <input>/square_2d.msh
  primary_equation: !Steady_MH
  
    input_fields:
      - region: plane
        conductivity: 1
      - r_set: BOUNDARY
        time: 0
        bc_type: dirichlet
        bc_pressure: !FieldFormula 0
      - r_set: BOUNDARY
        time: 1
        bc_type: dirichlet
        bc_pressure: !FieldFormula x
      - r_set: BOUNDARY
        time: 2
        bc_type: dirichlet
        bc_pressure: !FieldFormula 2*x
          
    n_schurs: 2
    
    output:
      output_stream:
        add_input_times: true
        file: ./test09.pvd
        format: !vtk
          variant: ascii
        name: flow_output_stream
      output_fields:
        - pressure_p0
        - pressure_p1
        - velocity_p0
        
    balance: true
    
    solver: !Petsc
      a_tol: 1.0e-07
\end{lstlisting}
\vspace*{-20pt}
\caption{Konfigurační soubor \texttt{flow\_time\_dep} ve formátu YAML}
\label{img:reference-con}
\end{figure}


\chapter{Grafické rozhraní aplikace}
\label{apx:gui}

\begin{figure}[h]
	\centering
    \includegraphics[width=\textwidth]{../img/screenshots/gui_overview.png}
    \caption{GUI -- Přehled rozhraní aplikace}
	\label{img:gui_overview}
\end{figure}

\begin{figure}[h]
	\centering
    \includegraphics[width=0.5\textwidth]{../img/screenshots/gui_tree.png}
    \caption{GUI -- Komponenta stromu pro vizualizaci dat}
	\label{img:gui_tree}
\end{figure}

\clearpage

\begin{figure}[ht]
	\centering
    \includegraphics[width=\textwidth]{../img/screenshots/gui_editor_notifications.png}
    \caption{GUI -- Komponenta textového editoru s~notifikacemi}
	\label{img:gui_editor_notifications}
\end{figure}

\begin{figure}[h]
	\centering
    \includegraphics[width=\textwidth]{../img/screenshots/gui_notifications.png}
    \caption{GUI -- Komponenta seznamu notifikací}
	\label{img:gui_notifications}
\end{figure}

\begin{figure}[H]
	\centering
    \includegraphics[width=\textwidth]{../img/screenshots/gui_editor_autocompletion.png}
    \caption{GUI -- Komponenta textového editoru s~doplňováním textu}
	\label{img:gui_editor_autocompletion}
\end{figure}

\clearpage

\begin{figure}[h!]
	\centering
    \includegraphics[width=\textwidth]{../img/screenshots/gui_doc_mortar_method.png}
    \caption[GUI -- Kontextová nápověda pro záznam \textit{Steady\_MH}]{GUI -- Komponenta kontextové nápovědy zobrazující dokumentaci k~hodnotě \texttt{P0} výčtového typu \textit{MH\_MortartMethod} v~klíči \texttt{mortar\_method} v~záznamu \textit{Steady\_MH}, který implementuje abstraktní záznam \textit{DarcyFlow}}
	\label{img:gui_doc_mortar_method}
\end{figure}

\begin{figure}[h!]
	\centering
    \includegraphics[width=\textwidth]{../img/screenshots/gui_doc_substances.png}
    \caption[GUI -- Kontextová nápověda pro záznam \textit{SoluteTransport\_DG}]{GUI -- Komponenta kontextové nápovědy zobrazující dokumentaci k~poli záznamů \textit{Substance} v~klíči \texttt{substances} v~záznamu \textit{SoluteTransport\_DG}, který implementuje abstraktní záznam \textit{Transport}}
	\label{img:gui_doc_substances}
\end{figure}

\begin{figure}[h!]
	\centering
    \includegraphics[width=\textwidth]{../img/screenshots/gui_doc_format.png}
    \caption[GUI -- Kontextová nápověda pro záznam \textit{OutputStream}]{GUI -- Komponenta kontextové nápovědy zobrazující dokumentaci k~abstraktnímu záznamu \textit{OutputTime} v~klíči \texttt{format} v~záznamu \textit{OutputStream}}
	\label{img:gui_doc_format}
\end{figure}

\clearpage

\chapter{Obsah přiloženého CD}

\dirtree{%
.1 /.
.2 img\DTcomment{Obrázky použité v~diplomové práci.}.
.2 git\DTcomment{Zdrojové kódy a testy (git commit \texttt{234f0da}).}.
.2 dp\_krizek\_2016.pdf\DTcomment{Text diplomové práce ve formátu pdf.}.
.2 modeleditor\_234f0da.deb\DTcomment{Instalační balíček pro Debian.}.
.2 modeleditor\_234f0da.exe\DTcomment{Instalační soubor pro systémy Windows.}.
}

\end{document}
